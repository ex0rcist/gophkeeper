
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>keeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gophkeeper/cmd/keeper/main.go (0.0%)</option>
				
				<option value="file1">gophkeeper/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">gophkeeper/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file3">gophkeeper/internal/keeper/api/grpc/client.go (39.5%)</option>
				
				<option value="file4">gophkeeper/internal/keeper/api/grpc/interceptor/auth.go (100.0%)</option>
				
				<option value="file5">gophkeeper/internal/keeper/api/grpc/interceptor/timeout.go (0.0%)</option>
				
				<option value="file6">gophkeeper/internal/keeper/config/config.go (0.0%)</option>
				
				<option value="file7">gophkeeper/internal/keeper/crypto/crypto.go (73.8%)</option>
				
				<option value="file8">gophkeeper/internal/keeper/entities/address.go (0.0%)</option>
				
				<option value="file9">gophkeeper/internal/keeper/entities/secret.go (100.0%)</option>
				
				<option value="file10">gophkeeper/internal/keeper/keeper.go (0.0%)</option>
				
				<option value="file11">gophkeeper/internal/keeper/storage/file.go (78.9%)</option>
				
				<option value="file12">gophkeeper/internal/keeper/storage/remote.go (69.4%)</option>
				
				<option value="file13">gophkeeper/internal/keeper/tui/app/app.go (0.0%)</option>
				
				<option value="file14">gophkeeper/internal/keeper/tui/cache.go (0.0%)</option>
				
				<option value="file15">gophkeeper/internal/keeper/tui/commands.go (0.0%)</option>
				
				<option value="file16">gophkeeper/internal/keeper/tui/components/input.go (0.0%)</option>
				
				<option value="file17">gophkeeper/internal/keeper/tui/components/input_group.go (0.0%)</option>
				
				<option value="file18">gophkeeper/internal/keeper/tui/messages.go (0.0%)</option>
				
				<option value="file19">gophkeeper/internal/keeper/tui/pane_manager.go (0.0%)</option>
				
				<option value="file20">gophkeeper/internal/keeper/tui/prompt.go (0.0%)</option>
				
				<option value="file21">gophkeeper/internal/keeper/tui/screens/blob_edit/blob_edit.go (0.0%)</option>
				
				<option value="file22">gophkeeper/internal/keeper/tui/screens/blob_edit/file_pick.go (0.0%)</option>
				
				<option value="file23">gophkeeper/internal/keeper/tui/screens/card_edit/card_edit.go (0.0%)</option>
				
				<option value="file24">gophkeeper/internal/keeper/tui/screens/credential_edit/credential_edit.go (0.0%)</option>
				
				<option value="file25">gophkeeper/internal/keeper/tui/screens/login/login.go (0.0%)</option>
				
				<option value="file26">gophkeeper/internal/keeper/tui/screens/menu/item.go (0.0%)</option>
				
				<option value="file27">gophkeeper/internal/keeper/tui/screens/menu/menu.go (0.0%)</option>
				
				<option value="file28">gophkeeper/internal/keeper/tui/screens/remote_open/remote_open.go (0.0%)</option>
				
				<option value="file29">gophkeeper/internal/keeper/tui/screens/screens.go (0.0%)</option>
				
				<option value="file30">gophkeeper/internal/keeper/tui/screens/secret_type/item.go (0.0%)</option>
				
				<option value="file31">gophkeeper/internal/keeper/tui/screens/secret_type/secret_type.go (0.0%)</option>
				
				<option value="file32">gophkeeper/internal/keeper/tui/screens/storage_browse/storage_browse.go (0.0%)</option>
				
				<option value="file33">gophkeeper/internal/keeper/tui/screens/storage_create/storage_create.go (0.0%)</option>
				
				<option value="file34">gophkeeper/internal/keeper/tui/screens/storage_open/storage_open.go (0.0%)</option>
				
				<option value="file35">gophkeeper/internal/keeper/tui/screens/text_edit/text_edit.go (0.0%)</option>
				
				<option value="file36">gophkeeper/internal/keeper/tui/screens/welcome/welcome.go (0.0%)</option>
				
				<option value="file37">gophkeeper/internal/keeper/tui/top/makers.go (0.0%)</option>
				
				<option value="file38">gophkeeper/internal/keeper/tui/top/model.go (0.0%)</option>
				
				<option value="file39">gophkeeper/internal/keeper/tui/tui.go (0.0%)</option>
				
				<option value="file40">gophkeeper/internal/keeper/usecase/create_storage.go (0.0%)</option>
				
				<option value="file41">gophkeeper/internal/keeper/utils/logger.go (90.0%)</option>
				
				<option value="file42">gophkeeper/internal/keeper/utils/rand.go (80.0%)</option>
				
				<option value="file43">gophkeeper/internal/server/auth/auth.go (85.3%)</option>
				
				<option value="file44">gophkeeper/internal/server/config/config.go (0.0%)</option>
				
				<option value="file45">gophkeeper/internal/server/entities/address.go (100.0%)</option>
				
				<option value="file46">gophkeeper/internal/server/entities/errors.go (0.0%)</option>
				
				<option value="file47">gophkeeper/internal/server/entities/filepath.go (100.0%)</option>
				
				<option value="file48">gophkeeper/internal/server/entities/secret.go (80.0%)</option>
				
				<option value="file49">gophkeeper/internal/server/grpcbackend/backend.go (0.0%)</option>
				
				<option value="file50">gophkeeper/internal/server/grpcbackend/entities.go (0.0%)</option>
				
				<option value="file51">gophkeeper/internal/server/grpcbackend/handlers/health.go (100.0%)</option>
				
				<option value="file52">gophkeeper/internal/server/grpcbackend/handlers/secrets.go (80.9%)</option>
				
				<option value="file53">gophkeeper/internal/server/grpcbackend/handlers/users.go (57.9%)</option>
				
				<option value="file54">gophkeeper/internal/server/grpcbackend/interceptor/auth.go (92.3%)</option>
				
				<option value="file55">gophkeeper/internal/server/grpcbackend/interceptor/helper.go (40.0%)</option>
				
				<option value="file56">gophkeeper/internal/server/grpcbackend/interceptor/logger.go (100.0%)</option>
				
				<option value="file57">gophkeeper/internal/server/grpcbackend/server.go (0.0%)</option>
				
				<option value="file58">gophkeeper/internal/server/repository/postgres/secret.go (62.8%)</option>
				
				<option value="file59">gophkeeper/internal/server/repository/postgres/user.go (94.1%)</option>
				
				<option value="file60">gophkeeper/internal/server/server.go (0.0%)</option>
				
				<option value="file61">gophkeeper/internal/server/service/health.go (88.9%)</option>
				
				<option value="file62">gophkeeper/internal/server/service/secret.go (50.0%)</option>
				
				<option value="file63">gophkeeper/internal/server/service/user.go (92.0%)</option>
				
				<option value="file64">gophkeeper/internal/server/storage/postgres/conn.go (0.0%)</option>
				
				<option value="file65">gophkeeper/internal/server/storage/postgres/postgres.go (0.0%)</option>
				
				<option value="file66">gophkeeper/internal/server/utils/logger.go (90.0%)</option>
				
				<option value="file67">gophkeeper/internal/server/utils/luhn.go (100.0%)</option>
				
				<option value="file68">gophkeeper/internal/server/utils/request_id.go (100.0%)</option>
				
				<option value="file69">gophkeeper/internal/server/utils/security.go (81.8%)</option>
				
				<option value="file70">gophkeeper/pkg/convert/secret.go (100.0%)</option>
				
				<option value="file71">gophkeeper/pkg/models/secret.go (65.9%)</option>
				
				<option value="file72">gophkeeper/pkg/staticlint/staticlint.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "gophkeeper/internal/keeper"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/api/grpc"
        "gophkeeper/internal/keeper/config"
        "gophkeeper/internal/keeper/tui/app"
        "gophkeeper/internal/keeper/tui/top"
        "gophkeeper/internal/keeper/utils"
        "log"

        "go.uber.org/dig"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        cfg := config.New()
        cfg.BuildDate = buildDate
        cfg.BuildVersion = buildVersion

        err := runApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to start app: ", err)
        }</span>
}

func runApp(cfg *config.Config) error <span class="cov0" title="0">{
        cont := buildDepContainer(cfg)

        return cont.Invoke(func(keeper *keeper.Keeper) error </span><span class="cov0" title="0">{
                return keeper.Start()
        }</span>)
}

func buildDepContainer(cfg *config.Config) *dig.Container <span class="cov0" title="0">{
        container := dig.New()

        // NB: could use .Provide(config.New), but try to avoid
        // parsing config twice, using closure instead
        _ = container.Provide(func() *config.Config </span><span class="cov0" title="0">{ return cfg }</span>)

        // Keeper
        <span class="cov0" title="0">_ = container.Provide(keeper.NewKeeper)

        // GRPC client
        _ = container.Provide(grpc.NewGRPCClient, dig.As(new(api.IApiClient)))

        // TUI app
        _ = container.Provide(app.NewApp)

        // Top app model
        _ = container.Provide(top.NewModel)

        // Logging
        _ = container.Provide(utils.NewZapLogger)
        _ = container.Provide(func(cfg *config.Config) utils.ZapLogLevel </span><span class="cov0" title="0">{ return utils.ZapLogLevel(cfg.LogLevel) }</span>)

        <span class="cov0" title="0">return container</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "gophkeeper/internal/server"
        "gophkeeper/internal/server/config"
        "gophkeeper/internal/server/grpcbackend"
        grpchandlers "gophkeeper/internal/server/grpcbackend/handlers"
        "gophkeeper/internal/server/repository"
        "gophkeeper/internal/server/service"
        "gophkeeper/internal/server/storage"
        "gophkeeper/internal/server/utils"

        pgRepo "gophkeeper/internal/server/repository/postgres"
        pgStorage "gophkeeper/internal/server/storage/postgres"

        "github.com/go-chi/chi/v5"
        "go.uber.org/dig"
)

func main() <span class="cov0" title="0">{
        cfg := config.New()

        if cfg.PostgresDSN == "" </span><span class="cov0" title="0">{
                fmt.Println("please provide GOPH_POSTGRES_DSN in ENV")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err := runApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to start app: ", err)
        }</span>
}

// Single entry point for all app's dependencies
func runApp(cfg *config.Config) error <span class="cov0" title="0">{
        cont := buildDepContainer(cfg)
        cont = addAppSpecificDependencies(cont, cfg)

        return cont.Invoke(func(server *server.Server) error </span><span class="cov0" title="0">{
                return server.Start()
        }</span>)
}

func buildDepContainer(cfg *config.Config) *dig.Container <span class="cov0" title="0">{
        container := dig.New()

        // NB: could use .Provide(config.New), but try to avoid
        // parsing config twice, using closure instead
        _ = container.Provide(func() *config.Config </span><span class="cov0" title="0">{ return cfg }</span>)

        // Server
        <span class="cov0" title="0">_ = container.Provide(server.New)

        // Logging
        _ = container.Provide(utils.NewZapLogger)
        _ = container.Provide(func(cfg *config.Config) utils.ZapLogLevel </span><span class="cov0" title="0">{ return utils.ZapLogLevel(cfg.LogLevel) }</span>)

        // Routing
        <span class="cov0" title="0">_ = container.Provide(chi.NewRouter, dig.As(new(chi.Router)))

        // HTTP server and backend
        _ = container.Provide(grpcbackend.NewGRPCServer)
        _ = container.Provide(grpcbackend.NewBackend)
        _ = container.Provide(grpcbackend.NewGRPCServerAddress)

        // HTTP handlers
        _ = container.Provide(grpchandlers.NewUsersServer)
        _ = container.Provide(grpchandlers.NewHealthServer)
        _ = container.Provide(grpchandlers.NewSecretsServer)
        // TODO: notification server

        // services
        _ = container.Provide(service.NewHealthService, dig.As(new(service.HealthManager)))
        _ = container.Provide(service.NewSecretsService, dig.As(new(service.SecretsManager)))
        _ = container.Provide(service.NewUsersService, dig.As(new(service.UsersManager)))

        return container</span>
}

func addAppSpecificDependencies(container *dig.Container, cfg *config.Config) *dig.Container <span class="cov0" title="0">{
        switch </span>{
        case len(cfg.PostgresDSN) &gt; 0:<span class="cov0" title="0">
                // Postgres storage
                _ = container.Provide(pgStorage.NewPostgresDSN)
                _ = container.Provide(pgStorage.NewPostgresConn)
                _ = container.Provide(pgStorage.NewPostgresStorage, dig.As(new(storage.ServerStorage)))

                // Postgres repos
                _ = container.Provide(pgRepo.NewUsersRepository, dig.As(new(repository.UsersRepository)))
                _ = container.Provide(pgRepo.NewSecretsRepository, dig.As(new(repository.SecretsRepository)))</span>
        }

        <span class="cov0" title="0">return container</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import "gophkeeper/pkg/staticlint"

func main() <span class="cov0" title="0">{
        lint := staticlint.New()
        lint.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package grpc

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "gophkeeper/cert"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/api/grpc/interceptor"
        "gophkeeper/internal/keeper/config"
        "gophkeeper/internal/keeper/entities"
        "gophkeeper/pkg/convert"
        "gophkeeper/pkg/models"
        "log"
        "math"
        "math/rand/v2"
        "sync"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"

        pb "gophkeeper/pkg/proto/keeper/grpcapi"
)

const (
        DefaultClientTimeout = time.Second * 5
)

type GRPCClient struct {
        config        *config.Config
        usersClient   pb.UsersClient
        secretsClient pb.SecretsClient
        notifyClient  pb.NotificationClient
        accessToken   string
        password      string // passw to encrypt payload
        clientID      int32  // Unique ID to distinguish between multiple running clients for same user
        previews      sync.Map
}

var _ api.IApiClient = &amp;GRPCClient{}

func NewGRPCClient(cfg *config.Config) (*GRPCClient, error) <span class="cov0" title="0">{
        var opts []grpc.DialOption

        newClient := GRPCClient{
                config:   cfg,
                clientID: int32(rand.IntN(math.MaxInt32)),
        }

        // Unary interceptors
        opts = append(
                opts,
                grpc.WithChainUnaryInterceptor(
                        interceptor.Timeout(DefaultClientTimeout),
                        interceptor.AddAuth(&amp;newClient.accessToken, newClient.clientID),
                ),
        )

        // TLS
        if cfg.EnableTLS </span><span class="cov0" title="0">{
                tlsCredential, err := loadTLSConfig("ca-cert.pem", "client-cert.pem", "client-key.pem")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load TLS config: %w", err)
                }</span>

                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(tlsCredential))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))
        }</span>

        // create gRPC client
        <span class="cov0" title="0">c, err := grpc.NewClient(string(cfg.ServerAddress), opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create gRPC client: %w", err)
        }</span>

        // register services
        <span class="cov0" title="0">newClient.usersClient = pb.NewUsersClient(c)
        newClient.secretsClient = pb.NewSecretsClient(c)
        newClient.notifyClient = pb.NewNotificationClient(c)

        return &amp;newClient, nil</span>
}

func (c *GRPCClient) Login(ctx context.Context, login string, password string) (string, error) <span class="cov4" title="2">{
        req := &amp;pb.LoginRequestV1{
                Login:    login,
                Password: password,
        }

        response, err := c.usersClient.LoginV1(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return "", parseError(err)
        }</span>

        <span class="cov1" title="1">c.accessToken = response.AccessToken

        return response.AccessToken, nil</span>
}

func (c *GRPCClient) Register(ctx context.Context, login string, password string) (string, error) <span class="cov4" title="2">{
        req := &amp;pb.RegisterRequestV1{
                Login:    login,
                Password: password,
        }

        response, err := c.usersClient.RegisterV1(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return "", parseError(err)
        }</span>

        <span class="cov1" title="1">c.accessToken = response.AccessToken

        return response.AccessToken, nil</span>
}

func (c *GRPCClient) LoadSecrets(ctx context.Context) ([]*models.Secret, error) <span class="cov4" title="2">{
        // form gRPC request
        request := emptypb.Empty{}

        // performing gRPC call
        response, err := c.secretsClient.GetUserSecretsV1(ctx, &amp;request)
        if err != nil </span><span class="cov1" title="1">{
                return nil, parseError(err)
        }</span>

        <span class="cov1" title="1">secrets := convert.ProtoToSecrets(response.Secrets)
        return secrets, nil</span>
}

func (c *GRPCClient) LoadSecret(ctx context.Context, ID uint64) (*models.Secret, error) <span class="cov0" title="0">{
        // form gRPC request
        request := &amp;pb.GetUserSecretRequestV1{
                Id: ID,
        }

        // performing gRPC call
        response, err := c.secretsClient.GetUserSecretV1(context.Background(), request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, parseError(err)
        }</span>

        <span class="cov0" title="0">secret := convert.ProtoToSecret(response.Secret)

        return secret, nil</span>
}

func (c *GRPCClient) SaveSecret(ctx context.Context, secret *models.Secret) error <span class="cov4" title="2">{
        sec := &amp;pb.Secret{
                Title:      secret.Title,
                Metadata:   secret.Metadata,
                SecretType: convert.TypeToProto(secret.SecretType),
                Payload:    secret.Payload,
                CreatedAt:  timestamppb.New(secret.CreatedAt),
                UpdatedAt:  timestamppb.New(secret.UpdatedAt),
        }

        if secret.ID &gt; 0 </span><span class="cov4" title="2">{
                sec.Id = secret.ID
        }</span>

        <span class="cov4" title="2">request := &amp;pb.SaveUserSecretRequestV1{Secret: sec}
        _, err := c.secretsClient.SaveUserSecretV1(ctx, request)

        return parseError(err)</span>
}

func (c *GRPCClient) DeleteSecret(ctx context.Context, id uint64) error <span class="cov4" title="2">{
        request := &amp;pb.DeleteUserSecretRequestV1{Id: id}
        _, err := c.secretsClient.DeleteUserSecretV1(ctx, request)

        return parseError(err)
}</span>

func (c *GRPCClient) SetToken(token string) <span class="cov0" title="0">{
        c.accessToken = token
}</span>

func (c *GRPCClient) GetToken() string <span class="cov0" title="0">{
        return c.accessToken
}</span>

func (c *GRPCClient) SetPassword(password string) <span class="cov0" title="0">{
        c.password = password
}</span>

func (c *GRPCClient) GetPassword() string <span class="cov0" title="0">{
        return c.password
}</span>

func parseError(err error) error <span class="cov10" title="7">{
        if err == nil </span><span class="cov4" title="2">{
                return nil
        }</span>

        <span class="cov8" title="5">st, ok := status.FromError(err)
        if !ok </span><span class="cov8" title="5">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.Unavailable:<span class="cov0" title="0">
                log.Println(err)
                return entities.ErrServerUnavailable</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return entities.ErrUnauthenticated</span>
        case codes.AlreadyExists:<span class="cov0" title="0">
                return entities.ErrAlreadyExist</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func loadTLSConfig(caCertFile, clientCertFile, clientKeyFile string) (credentials.TransportCredentials, error) <span class="cov0" title="0">{
        // Read CA cert
        caPem, err := cert.Cert.ReadFile(caCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CA cert: %w", err)
        }</span>

        // Read client cert
        <span class="cov0" title="0">clientCertPEM, err := cert.Cert.ReadFile(clientCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read client cert: %w", err)
        }</span>

        // Read client key
        <span class="cov0" title="0">clientKeyPEM, err := cert.Cert.ReadFile(clientKeyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read client key: %w", err)
        }</span>

        // Create key pair
        <span class="cov0" title="0">clientCert, err := tls.X509KeyPair(clientCertPEM, clientKeyPEM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load x509 key pair: %w", err)
        }</span>

        // Create cert pool and append CA's cert
        <span class="cov0" title="0">certPool := x509.NewCertPool()
        if !certPool.AppendCertsFromPEM(caPem) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to append CA cert to cert pool: %w", err)
        }</span>

        // Create config
        <span class="cov0" title="0">config := &amp;tls.Config{
                Certificates: []tls.Certificate{clientCert},
                RootCAs:      certPool,
        }

        return credentials.NewTLS(config), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Client gRPC interceptors
package interceptor

import (
        "context"
        "gophkeeper/pkg/constants"
        "strconv"

        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

// Unary gRPC interceptor which adds auth token to metadata
func AddAuth(token *string, clientID int32) grpc.UnaryClientInterceptor <span class="cov10" title="2">{
        return func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov10" title="2">{
                // pass request if token is empty
                if len(*token) == 0 </span><span class="cov1" title="1">{
                        return invoker(ctx, method, req, reply, cc, opts...)
                }</span>

                // add access token to metadata
                <span class="cov1" title="1">md := metadata.New(map[string]string{
                        constants.AccessTokenHeader: *token,
                        constants.ClientIDHeader:    strconv.Itoa(int(clientID)),
                })

                mdCtx := metadata.NewOutgoingContext(ctx, md)
                return invoker(mdCtx, method, req, reply, cc, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package interceptor

import (
        "context"
        "time"

        "google.golang.org/grpc"
)

// Unary interceptor which adds standart timeout to all client requests
func Timeout(timeout time.Duration) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                timedCtx, cancel := context.WithTimeout(ctx, timeout)
                defer cancel()
                return invoker(timedCtx, method, req, reply, cc, opts...)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Keeper config
package config

import (
        "gophkeeper/internal/keeper/entities"
        "strings"

        "github.com/spf13/viper"
)

type Config struct {
        ServerAddress entities.Address
        Verbose       bool
        EnableTLS     bool
        LogLevel      string
        BuildDate     string
        BuildVersion  string
}

func New() *Config <span class="cov0" title="0">{
        viper.SetDefault("address", "127.0.0.1:50051")
        viper.SetDefault("verbose", false)

        viper.SetEnvPrefix("GOPH")
        viper.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
        viper.AutomaticEnv()

        cfg := &amp;Config{
                ServerAddress: entities.Address(viper.GetString("address")),
                Verbose:       viper.GetBool("verbose"),
                EnableTLS:     true,
        }

        return cfg
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Provides functions necessary for encryption and decryption
package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "fmt"
        "gophkeeper/internal/keeper/entities"
        "gophkeeper/internal/keeper/utils"
        "strings"

        "golang.org/x/crypto/pbkdf2"
)

const saltLen = 8

var _ Encrypter = (*KeeperEncrypter)(nil)

type Encrypter interface {
        Encrypt(data []byte, password string) ([]byte, error)
        Decrypt(encrypted []byte, password string) ([]byte, error)
}

type KeeperEncrypter struct {
        saltLen int
}

func NewKeeperEncrypter() *KeeperEncrypter <span class="cov1" title="1">{
        return &amp;KeeperEncrypter{saltLen: saltLen}
}</span>

func (e KeeperEncrypter) Encrypt(plaintext []byte, password string) ([]byte, error) <span class="cov1" title="1">{
        key, salt, err := e.deriveKey(password, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive key: %w", err)
        }</span>

        // creating AES block
        <span class="cov1" title="1">AESBlock, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // creating GCM
        <span class="cov1" title="1">GCM, err := cipher.NewGCM(AESBlock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // generating nonce
        <span class="cov1" title="1">nonce, err := utils.GenerateRandom(GCM.NonceSize())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // encrypt data
        <span class="cov1" title="1">encrypted := GCM.Seal(nonce, nonce, plaintext, nil)

        // store salt alongside encrypted data
        encrypted = append(encrypted, salt...)

        return encrypted, nil</span>
}

func (e KeeperEncrypter) Decrypt(encrypted []byte, password string) ([]byte, error) <span class="cov1" title="1">{
        // extract salt
        saltIdx := len(encrypted) - e.saltLen
        salt := encrypted[saltIdx:]

        encrypted = encrypted[:saltIdx]

        key, _, err := e.deriveKey(password, salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive key: %w", err)
        }</span>

        // creating AES block
        <span class="cov1" title="1">AESBlock, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // creating GCM
        <span class="cov1" title="1">GCM, err := cipher.NewGCM(AESBlock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // extract nonce
        <span class="cov1" title="1">nonce := encrypted[:GCM.NonceSize()]
        encrypted = encrypted[GCM.NonceSize():]

        // decrypt data
        decrypted, err := GCM.Open(nil, nonce, encrypted, nil)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "message authentication failed") </span><span class="cov0" title="0">{
                        return nil, entities.ErrBadPassword
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to decrypt: %w", err)</span>
        }

        <span class="cov1" title="1">return decrypted, nil</span>
}

func (e KeeperEncrypter) deriveKey(password string, salt []byte) ([]byte, []byte, error) <span class="cov10" title="2">{
        if len(salt) == 0 </span><span class="cov1" title="1">{
                salt = make([]byte, e.saltLen)
                _, err := rand.Read(salt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }
        <span class="cov10" title="2">return pbkdf2.Key([]byte(password), salt, 4096, 32, sha256.New), salt, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package entities

import (
        "fmt"
        "strconv"
        "strings"
)

// https://github.com/spf13/pflag/blob/master/README.md#usage
// must comply with https://pkg.go.dev/github.com/spf13/pflag@v1.0.5#Value.
type Address string

// Stringer.
func (a Address) String() string <span class="cov0" title="0">{
        return string(a)
}</span>

// Set value.
func (a *Address) Set(src string) error <span class="cov0" title="0">{
        chunks := strings.Split(src, ":")
        if len(chunks) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("set address failed: %w", ErrBadAddressFormat)
        }</span>

        <span class="cov0" title="0">port := chunks[1]

        if _, err := strconv.Atoi(port); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set address failed: %w", err)
        }</span>

        <span class="cov0" title="0">*a = Address(src)

        return nil</span>
}

// Return string for correct type conversion.
func (a Address) Type() string <span class="cov0" title="0">{
        return "string"
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package entities

import (
        "strings"
)

// Entity to hide sensitive values which shouldn't leak to logs.
type Secret string

// Set value.
func (s *Secret) Set(src string) error <span class="cov10" title="7">{
        *s = Secret(src)

        return nil
}</span>

// Return a string for correct type conversion.
func (s Secret) Type() string <span class="cov1" title="1">{
        return "string"
}</span>

// Stringer.
func (s Secret) String() string <span class="cov8" title="5">{
        if len(s) &lt;= 2 </span><span class="cov6" title="3">{
                return string(s)
        }</span>

        <span class="cov4" title="2">masked := strings.Repeat("*", len(s)-2)
        return string(s[0]) + masked + string(s[len(s)-1])</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package keeper

import (
        "context"
        "errors"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/config"
        "gophkeeper/internal/keeper/tui/app"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go.uber.org/dig"
        "go.uber.org/zap"
)

var (
        errNotInitialized = errors.New("application is not initialized")
)

const shutdownTimeout = 5 * time.Second

type Keeper struct {
        config *config.Config
        tuiApp *app.App
        log    *zap.SugaredLogger

        client api.IApiClient
}

type KeeperDependencies struct {
        dig.In

        App    *app.App
        Config *config.Config
        Client api.IApiClient
        Logger *zap.SugaredLogger
}

func NewKeeper(deps KeeperDependencies) (*Keeper, error) <span class="cov0" title="0">{
        return &amp;Keeper{
                tuiApp: deps.App,
                config: deps.Config,
                client: deps.Client,
                log:    deps.Logger,
        }, nil
}</span>

func (k Keeper) Start() error <span class="cov0" title="0">{
        k.tuiApp.Start()

        // Graceful shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        select </span>{
        case sig := &lt;-quit:<span class="cov0" title="0">
                k.log.Info("interrupt: signal " + sig.String())</span>
        case err := &lt;-k.tuiApp.Notify():<span class="cov0" title="0">
                if errors.Is(err, app.ErrExitCmd) </span><span class="cov0" title="0">{
                        quit &lt;- syscall.SIGINT
                        break</span>
                }

                <span class="cov0" title="0">k.log.Error(err, "TUI app error")</span>
        }

        <span class="cov0" title="0">k.shutdown()

        return nil</span>
}

// Shutdown gracefully stops client application.
func (k Keeper) shutdown() <span class="cov0" title="0">{
        stopped := make(chan struct{})
        stopCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                // Shut down seervices here, if any
                // TODO: notification service

                close(stopped)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-stopped:<span class="cov0" title="0">
                k.log.Info("keeper shutdown successful")</span>

        case &lt;-stopCtx.Done():<span class="cov0" title="0">
                k.log.Info("shutdown timeout exceeded")</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/entities"
        "gophkeeper/pkg/models"
        "io"
        "log"
        "os"
        "slices"
        "sync"
)

var _ Storage = (*FileStorage)(nil)

// File-backed storage
type FileStorage struct {
        sync.RWMutex

        file *os.File
        Data map[uint64]models.Secret `json:"secrets"`

        encrypter crypto.Encrypter
        password  string
}

func NewFileStorage(path string, password string, encrypter crypto.Encrypter) (*FileStorage, error) <span class="cov4" title="2">{
        store := &amp;FileStorage{
                Data:      make(map[uint64]models.Secret),
                encrypter: encrypter,
                password:  password,
        }

        err := store.openOrCreateFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return store, nil</span>
}

func (store *FileStorage) Get(_ context.Context, id uint64) (*models.Secret, error) <span class="cov7" title="4">{
        store.Lock()
        defer store.Unlock()

        secret, ok := store.Data[id]
        secret.ID = id
        if !ok </span><span class="cov1" title="1">{
                return nil, entities.ErrSecretNotFound
        }</span>

        <span class="cov6" title="3">return &amp;secret, nil</span>
}

func (store *FileStorage) GetAll(_ context.Context) ([]*models.Secret, error) <span class="cov1" title="1">{
        store.Lock()
        defer store.Unlock()

        arr := make([]*models.Secret, len(store.Data))

        i := 0
        for id, secret := range store.Data </span><span class="cov4" title="2">{
                secret.ID = id
                arr[i] = &amp;secret
                i++
        }</span>

        <span class="cov1" title="1">return arr, nil</span>
}

func (store *FileStorage) Create(ctx context.Context, secret *models.Secret) error <span class="cov7" title="4">{
        store.Lock()
        defer store.Unlock()

        id := store.nextID()
        store.Data[id] = *secret

        return store.dump()
}</span>

func (store *FileStorage) Update(ctx context.Context, secret *models.Secret) error <span class="cov1" title="1">{
        store.Lock()
        defer store.Unlock()

        id := secret.ID
        store.Data[id] = *secret

        return store.dump()
}</span>

func (store *FileStorage) Delete(ctx context.Context, id uint64) error <span class="cov1" title="1">{
        store.Lock()
        defer store.Unlock()

        delete(store.Data, id)

        return store.dump()
}</span>

func (store *FileStorage) String() string <span class="cov0" title="0">{
        return store.file.Name()
}</span>

func (store *FileStorage) Close(_ context.Context) error <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                if serr := store.file.Close(); serr != nil </span><span class="cov0" title="0">{
                        log.Fatal("dump(): failed to close file: %w")
                }</span>
        }()

        <span class="cov1" title="1">err := store.dump()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return err</span>
}

func (store *FileStorage) openOrCreateFile(path string) error <span class="cov4" title="2">{
        store.Lock()
        defer store.Unlock()

        var (
                existedFile bool
                err         error
        )

        // Check if file already existed
        if _, err = os.Stat(path); err == nil </span><span class="cov4" title="2">{
                existedFile = true
        }</span>

        // Open file
        <span class="cov4" title="2">store.file, err = os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("openOrCreateFile(): failed to open file: %w", err)
        }</span>

        <span class="cov4" title="2">if !existedFile </span><span class="cov0" title="0">{
                if err := store.dump(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("openOrCreateFile -&gt; dump(): failed to write initial data: %w", err)
                }</span>
        } else<span class="cov4" title="2"> {
                // Read
                encryptedData, err := io.ReadAll(store.file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("openOrCreateFile -&gt; ReadAll(): failed to read file: %w", err)
                }</span>

                // Decrypt
                <span class="cov4" title="2">decryptedData, err := store.DecryptWithRecover(encryptedData, store.password)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case entities.ErrBadPassword, entities.ErrBadEncryption:<span class="cov0" title="0">
                                return err</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("openOrCreateFile -&gt; Decrypt(): failed to decrypt data: %w", err)</span>
                        }
                }

                // Unmarshal
                <span class="cov4" title="2">if err := json.Unmarshal(decryptedData, &amp;store.Data); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("openOrCreateFile -&gt; Unmarshal(): failed to decode Data: %w", err)
                }</span>

                // Reset pointer
                <span class="cov4" title="2">if _, err := store.file.Seek(0, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("restore(): failed to reset file pointer: %w", err)
                }</span>
        }

        <span class="cov4" title="2">return nil</span>
}

// Attempt to decode non-encoded file may cause panic
func (store *FileStorage) DecryptWithRecover(data []byte, password string) (res []byte, err error) <span class="cov4" title="2">{
        defer func() </span><span class="cov4" title="2">{ // defer can replace named return values
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = entities.ErrBadEncryption
                }</span>
        }()

        <span class="cov4" title="2">return store.encrypter.Decrypt(data, password)</span>
}

// Dump storage to file
func (store *FileStorage) dump() (err error) <span class="cov10" title="7">{
        // Serialize data
        data, err := json.Marshal(store.Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dump(): error serializing Data: %w", err)
        }</span>

        // Clear any existing data
        <span class="cov10" title="7">if err = store.file.Truncate(0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dump(): failed to truncate file: %w", err)
        }</span>

        // Encrypt data
        <span class="cov10" title="7">encryptedData, err := store.encrypter.Encrypt(data, store.password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dump(): error encrypting Data: %w", err)
        }</span>

        // Dump to file
        <span class="cov10" title="7">if _, err = store.file.Write(encryptedData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dump(): error writing encrypted Data to file: %w", err)
        }</span>

        // Reset pointer
        <span class="cov10" title="7">if _, err = store.file.Seek(0, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dump(): failed to reset file pointer: %w", err)
        }</span>

        <span class="cov10" title="7">return nil</span>
}

func (store *FileStorage) nextID() uint64 <span class="cov7" title="4">{
        if len(store.Data) == 0 </span><span class="cov4" title="2">{
                return 1
        }</span>

        <span class="cov4" title="2">ids := make([]uint64, len(store.Data))
        for k := range store.Data </span><span class="cov6" title="3">{
                ids = append(ids, k)
        }</span>

        <span class="cov4" title="2">return slices.Max(ids) + 1</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/pkg/models"
)

var _ Storage = (*RemoteStorage)(nil)

// Remote storage
type RemoteStorage struct {
        client    api.IApiClient
        encrypter crypto.Encrypter
        password  string // passw to encrypt payload
}

func NewRemoteStorage(client api.IApiClient, encrypter crypto.Encrypter) (*RemoteStorage, error) <span class="cov1" title="1">{
        if encrypter == nil </span><span class="cov0" title="0">{
                encrypter = crypto.NewKeeperEncrypter()
        }</span>

        <span class="cov1" title="1">store := &amp;RemoteStorage{
                client:    client,
                encrypter: encrypter,
                password:  client.GetPassword(),
        }

        return store, nil</span>
}

func (store *RemoteStorage) Get(_ context.Context, id uint64) (*models.Secret, error) <span class="cov1" title="1">{
        secret, err := store.client.LoadSecret(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">err = store.decryptPayload(secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return secret, nil</span>
}

func (store *RemoteStorage) GetAll(_ context.Context) ([]*models.Secret, error) <span class="cov1" title="1">{
        secrets, err := store.client.LoadSecrets(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">for _, s := range secrets </span><span class="cov6" title="2">{
                err = store.decryptPayload(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="1">return secrets, nil</span>
}

func (store *RemoteStorage) Create(ctx context.Context, secret *models.Secret) (err error) <span class="cov1" title="1">{
        err = store.encryptPayload(secret)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">err = store.client.SaveSecret(context.Background(), secret)
        return err</span>
}

func (store *RemoteStorage) Update(ctx context.Context, secret *models.Secret) (err error) <span class="cov1" title="1">{
        err = store.encryptPayload(secret)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">err = store.client.SaveSecret(context.Background(), secret)
        return err</span>
}

func (store *RemoteStorage) Delete(ctx context.Context, id uint64) (err error) <span class="cov1" title="1">{
        err = store.client.DeleteSecret(context.Background(), id)
        return err
}</span>

func (store *RemoteStorage) encryptPayload(secret *models.Secret) (err error) <span class="cov6" title="2">{
        // Marshal
        data, err := marshalSecret(secret)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encryptPayload(): error serializing data: %w", err)
        }</span>

        // Encrypt data
        <span class="cov6" title="2">encryptedData, err := store.encrypter.Encrypt(data, store.password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encryptPayload(): error encrypting Data: %w", err)
        }</span> else<span class="cov6" title="2"> {
                secret.Payload = encryptedData
        }</span>

        <span class="cov6" title="2">return err</span>
}

func (store *RemoteStorage) decryptPayload(secret *models.Secret) (err error) <span class="cov10" title="3">{
        // Decrypt data
        decryptedData, err := store.encrypter.Decrypt(secret.Payload, store.password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decryptPayload: failed to decrypt data: %w", err)

        }</span>

        // Unmarshal
        <span class="cov10" title="3">err = unmarshalSecret(secret, decryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decryptPayload: failed to unmarshal data: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func marshalSecret(secret *models.Secret) ([]byte, error) <span class="cov6" title="2">{
        var (
                data []byte
                err  error
        )

        switch models.SecretType(secret.SecretType) </span>{
        case models.CredSecret:<span class="cov6" title="2">
                data, err = json.Marshal(secret.Creds)</span>
        case models.TextSecret:<span class="cov0" title="0">
                data, err = json.Marshal(secret.Text)</span>
        case models.CardSecret:<span class="cov0" title="0">
                data, err = json.Marshal(secret.Card)</span>
        case models.BlobSecret:<span class="cov0" title="0">
                data, err = json.Marshal(secret.Blob)</span>
        }

        <span class="cov6" title="2">return data, err</span>
}

func unmarshalSecret(secret *models.Secret, data []byte) error <span class="cov10" title="3">{
        var err error

        switch models.SecretType(secret.SecretType) </span>{
        case models.CredSecret:<span class="cov1" title="1">
                err = json.Unmarshal(data, &amp;secret.Creds)</span>
        case models.TextSecret:<span class="cov0" title="0">
                err = json.Unmarshal(data, &amp;secret.Text)</span>
        case models.CardSecret:<span class="cov0" title="0">
                err = json.Unmarshal(data, &amp;secret.Card)</span>
        case models.BlobSecret:<span class="cov0" title="0">
                err = json.Unmarshal(data, &amp;secret.Blob)</span>
        }

        <span class="cov10" title="3">return err</span>
}

func (store *RemoteStorage) String() string <span class="cov0" title="0">{
        return "remote storage"
}</span>

func (store *RemoteStorage) Close(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package app

import (
        "errors"
        "fmt"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/config"
        "gophkeeper/internal/keeper/tui/top"
        "log"
        "os"

        tea "github.com/charmbracelet/bubbletea"
        "go.uber.org/dig"
)

const logFilePath = "debug.log"

var ErrExitCmd = errors.New("exit command")

// App describes TUI app
type App struct {
        config   *config.Config
        client   api.IApiClient
        deps     AppDependencies
        topModel *top.Model

        logFile *os.File
        notify  chan error
}

type AppDependencies struct {
        dig.In

        TopModel *top.Model
        Config   *config.Config
        Client   api.IApiClient
}

func NewApp(deps AppDependencies) *App <span class="cov0" title="0">{
        return &amp;App{
                topModel: deps.TopModel,
                config:   deps.Config,
                client:   deps.Client,
                notify:   make(chan error, 1),
                deps:     deps,
        }
}</span>

func (a App) Start() <span class="cov0" title="0">{
        a.setupLogging()

        p := tea.NewProgram(a.topModel, tea.WithAltScreen())

        // Run tea program
        go func() </span><span class="cov0" title="0">{
                _, err := p.Run()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to run bubbletea app: ", err)
                }</span>

                <span class="cov0" title="0">a.notify &lt;- ErrExitCmd</span>
        }()
}

func (a App) Shutdown() <span class="cov0" title="0">{
        err := a.logFile.Close()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (a App) Notify() chan error <span class="cov0" title="0">{
        return a.notify
}</span>

func (a *App) setupLogging() <span class="cov0" title="0">{
        var err error

        a.logFile, err = tea.LogToFile(logFilePath, "debug")
        if err != nil </span><span class="cov0" title="0">{
                a.notify &lt;- fmt.Errorf("failed to setup bubbletea log: %w", err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tui

import (
        tea "github.com/charmbracelet/bubbletea"
)

type Cache struct {
        cache map[Page]Teable
}

func NewCache() *Cache <span class="cov0" title="0">{
        return &amp;Cache{
                cache: make(map[Page]Teable),
        }
}</span>

func (c *Cache) Get(page Page) Teable <span class="cov0" title="0">{
        return c.cache[page]
}</span>

func (c *Cache) Put(page Page, model Teable) <span class="cov0" title="0">{
        c.cache[page] = model
}</span>

func (c *Cache) UpdateAll(msg tea.Msg) []tea.Cmd <span class="cov0" title="0">{
        cmds := make([]tea.Cmd, len(c.cache))
        var i int
        for k := range c.cache </span><span class="cov0" title="0">{
                cmds[i] = c.Update(k, msg)
                i++
        }</span>
        <span class="cov0" title="0">return cmds</span>
}

func (c *Cache) Update(key Page, msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        return c.cache[key].Update(msg)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package tui

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea"
)

type ErrorMsg error
type InfoMsg string

func ReportInfo(msg string, args ...any) tea.Cmd <span class="cov0" title="0">{
        return CmdHandler(InfoMsg(fmt.Sprintf(msg, args...)))
}</span>

func ReportError(err error) tea.Cmd <span class="cov0" title="0">{
        return CmdHandler(ErrorMsg(err))
}</span>

func NavigateTo(screen Screen, opts ...NavigateOption) tea.Cmd <span class="cov0" title="0">{
        return CmdHandler(NewNavigationMsg(screen, opts...))
}</span>

func SetBodyPane(screen Screen, opts ...NavigateOption) tea.Cmd <span class="cov0" title="0">{
        opts = append(opts, WithPosition(BodyPane))
        return NavigateTo(screen, opts...)
}</span>

func GoToStart() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                NavigateTo(WelcomeScreen, []NavigateOption{DisableFocus(), WithPosition(BodyPane)}...),
                NavigateTo(MenuScreen, []NavigateOption{WithPosition(LeftPane)}...),
        )
}</span>

func SetLeftPane(screen Screen) tea.Cmd <span class="cov0" title="0">{
        return NavigateTo(screen, WithPosition(LeftPane))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package components

import (
        "gophkeeper/internal/keeper/tui/styles"

        "github.com/charmbracelet/bubbles/textinput"
)

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func NewInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Provides different building blocks for TUI
package components

import (
        "fmt"
        "gophkeeper/internal/keeper/tui/styles"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/charmbracelet/bubbles/textinput"
)

var ()

type InputGroup struct {
        Inputs     []textinput.Model
        Buttons    []Button
        FocusIndex int

        totalPos int // total positions for cursor
}

type Button struct {
        Title string
        Cmd   func() tea.Cmd
}

func NewInputGroup(inputs []textinput.Model, buttons []Button) InputGroup <span class="cov0" title="0">{
        // Set styles
        for i, input := range inputs </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        input.Focus()
                        input.PromptStyle = styles.Focused
                        input.TextStyle = styles.Focused
                }</span>

                <span class="cov0" title="0">inputs[i] = input</span>
        }

        <span class="cov0" title="0">return InputGroup{
                Inputs:   inputs,
                Buttons:  buttons,
                totalPos: len(inputs) + len(buttons) - 1,
        }</span>
}

func (m InputGroup) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

func (m InputGroup) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var (
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "enter", "up", "down":<span class="cov0" title="0">
                        s := msg.String()

                        // Did the user press enter while the button was focused?
                        if s == "enter" </span><span class="cov0" title="0">{
                                butIdx := m.FocusIndex - len(m.Inputs)
                                if butIdx &gt;= 0 </span><span class="cov0" title="0">{
                                        return m, m.Buttons[butIdx].Cmd()
                                }</span>
                        }

                        // Cycle indexes
                        <span class="cov0" title="0">if s == "up" </span><span class="cov0" title="0">{
                                m.FocusIndex--
                        }</span> else<span class="cov0" title="0"> {
                                m.FocusIndex++
                        }</span>

                        <span class="cov0" title="0">if m.FocusIndex &gt; m.totalPos </span><span class="cov0" title="0">{
                                m.FocusIndex = 0
                        }</span> else<span class="cov0" title="0"> if m.FocusIndex &lt; 0 </span><span class="cov0" title="0">{
                                m.FocusIndex = m.totalPos
                        }</span>

                        <span class="cov0" title="0">for i := 0; i &lt;= len(m.Inputs)-1; i++ </span><span class="cov0" title="0">{
                                if i == m.FocusIndex </span><span class="cov0" title="0">{
                                        // Set focused state
                                        cmds = append(cmds, m.Inputs[i].Focus())
                                        m.Inputs[i].PromptStyle = styles.Focused
                                        m.Inputs[i].TextStyle = styles.Focused
                                        continue</span>
                                }

                                // Remove focused state
                                <span class="cov0" title="0">m.Inputs[i].Blur()
                                m.Inputs[i].PromptStyle = styles.Regular
                                m.Inputs[i].TextStyle = styles.Regular</span>
                        }

                }
        }

        // Handle character input and blinking
        <span class="cov0" title="0">cmd := m.updateInputs(msg)
        cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}

func (m *InputGroup) updateInputs(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        cmds := make([]tea.Cmd, len(m.Inputs))

        for i := range m.Inputs </span><span class="cov0" title="0">{
                m.Inputs[i], cmds[i] = m.Inputs[i].Update(msg)
        }</span>

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (m InputGroup) View() string <span class="cov0" title="0">{
        var (
                b       strings.Builder
                style   lipgloss.Style
                padding int // num spaces to pad
        )

        // Calc max label width
        maxLabelLength := 0
        for _, input := range m.Inputs </span><span class="cov0" title="0">{
                if len(input.Placeholder) &gt; maxLabelLength </span><span class="cov0" title="0">{
                        maxLabelLength = len(input.Placeholder)
                }</span>
        }

        // Draw inputs
        <span class="cov0" title="0">for _, input := range m.Inputs </span><span class="cov0" title="0">{
                label := input.Placeholder
                padding = maxLabelLength - len(label) // Align right

                b.WriteString(fmt.Sprintf("%s: %s\n",
                        strings.Repeat(" ", padding)+label, // Add padding
                        input.View(),
                ))
        }</span>

        <span class="cov0" title="0">b.WriteRune('\n')

        // Draw buttons
        buttonPadding := maxLabelLength + 2 // 2 for `: `
        for i, but := range m.Buttons </span><span class="cov0" title="0">{
                title := but.Title

                if m.FocusIndex == len(m.Inputs)+i </span><span class="cov0" title="0">{
                        style = styles.Focused
                }</span> else<span class="cov0" title="0"> {
                        style = styles.Blurred
                }</span>

                <span class="cov0" title="0">b.WriteString(fmt.Sprintf("%s%s\n",
                        strings.Repeat(" ", buttonPadding),
                        style.Render(title),
                ))</span>
        }

        <span class="cov0" title="0">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package tui

import (
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/pkg/models"

        tea "github.com/charmbracelet/bubbletea"
)

type NavigationCallback func(args ...any) tea.Cmd

// NavigationMsg is an instruction to navigate to a page
type NavigationMsg struct {
        Screen       Screen
        Page         Page
        Position     Position
        DisableFocus bool

        Callback NavigationCallback
        Client   api.IApiClient
        Secret   *models.Secret
        Storage  storage.Storage
}

func NewNavigationMsg(screen Screen, opts ...NavigateOption) NavigationMsg <span class="cov0" title="0">{
        msg := NavigationMsg{Page: Page{Screen: screen}}
        for _, fn := range opts </span><span class="cov0" title="0">{
                fn(&amp;msg)
        }</span>
        <span class="cov0" title="0">return msg</span>
}

type NavigateOption func(msg *NavigationMsg)

func WithCallback(c NavigationCallback) NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.Callback = c
        }</span>
}

func WithClient(c api.IApiClient) NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.Client = c
        }</span>
}

func WithPosition(position Position) NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.Position = position
        }</span>
}

func WithStorage(strg storage.Storage) NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.Storage = strg
        }</span>
}

func WithSecret(sec *models.Secret) NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.Secret = sec
        }</span>
}

func DisableFocus() NavigateOption <span class="cov0" title="0">{
        return func(msg *NavigationMsg) </span><span class="cov0" title="0">{
                msg.DisableFocus = true
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package tui

import (
        "errors"
        "gophkeeper/internal/keeper/tui/styles"
        "slices"

        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "golang.org/x/exp/maps"
)

type Screen int

const (
        MenuScreen Screen = iota
        WelcomeScreen
        StorageCreateScreen
        StorageOpenScreen
        StorageBrowseScreen
        SecretTypeScreen
        FilePickScreen
        LoginScreen
        RegisterScreen
        RemoteOpenScreen

        CredentialEditScreen
        TextEditScreen
        CardEditScreen
        BlobEditScreen
)

var (
        ErrNoMaker = errors.New("no maker for requested screen")
)

type Position int

const (
        BodyPane Position = iota
        LeftPane
)

const borderSize = 2

type PaneManager struct {
        makers        map[Screen]ScreenMaker
        cache         *Cache            // cache of previously made models
        focused       Position          // the position of the currently focused pane
        panes         map[Position]pane // panes tracks currently visible panes
        width, height int               // total width and height of the terminal space available to panes.
}

type pane struct {
        model Teable
        page  Page
}

func NewPaneManager(makers map[Screen]ScreenMaker) *PaneManager <span class="cov0" title="0">{
        p := &amp;PaneManager{
                makers: makers,
                cache:  NewCache(),
                panes:  make(map[Position]pane),
        }
        return p
}</span>

func (pm *PaneManager) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                SetLeftPane(MenuScreen),
                SetBodyPane(WelcomeScreen),
        )
}</span>

func (pm *PaneManager) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch </span>{
                case key.Matches(msg, GlobalKeys.Tab):<span class="cov0" title="0">
                        pm.cycleFocusedPane()</span>
                default:<span class="cov0" title="0">
                        // Send remaining keys to focused pane
                        cmds = append(cmds, pm.updateModel(pm.focused, msg))</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                pm.width = msg.Width
                pm.height = msg.Height

                pm.updateChildSizes()</span>
        case NavigationMsg:<span class="cov0" title="0">
                cmds = append(cmds, pm.setPane(msg))</span>
        default:<span class="cov0" title="0">
                // Send remaining message types to cached panes
                cmds = pm.cache.UpdateAll(msg)</span>
        }

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (pm *PaneManager) FocusedModel() Teable <span class="cov0" title="0">{
        return pm.panes[pm.focused].model
}</span>

func (pm *PaneManager) cycleFocusedPane() <span class="cov0" title="0">{
        positions := maps.Keys(pm.panes)
        slices.Sort(positions)

        focusedIndex := int(pm.focused)
        totalPanes := len(pm.panes)

        if focusedIndex &gt;= totalPanes-1 </span><span class="cov0" title="0">{
                focusedIndex = 0
        }</span> else<span class="cov0" title="0"> {
                focusedIndex++
        }</span>

        <span class="cov0" title="0">pm.focusPane(positions[focusedIndex])</span>
}

func (pm *PaneManager) updateChildSizes() <span class="cov0" title="0">{
        for position := range pm.panes </span><span class="cov0" title="0">{
                pm.updateModel(position, tea.WindowSizeMsg{
                        Width:  pm.paneWidth(position) - borderSize,
                        Height: pm.paneHeight(position) - borderSize,
                })
        }</span>
}

func (pm *PaneManager) updateModel(position Position, msg tea.Msg) tea.Cmd <span class="cov0" title="0">{

        if p, ok := pm.panes[position]; ok </span><span class="cov0" title="0">{
                return p.model.Update(msg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pm *PaneManager) setPane(msg NavigationMsg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd tea.Cmd
        )

        if p, ok := pm.panes[msg.Position]; ok &amp;&amp; p.page == msg.Page </span><span class="cov0" title="0">{
                // Pane is already showing requested page, so just bring it into focus.
                if !msg.DisableFocus </span><span class="cov0" title="0">{
                        pm.focusPane(msg.Position)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // TODO: cache invalidation
        <span class="cov0" title="0">useCache := true

        model := pm.cache.Get(msg.Page)
        if useCache || model == nil </span><span class="cov0" title="0">{

                maker, ok := pm.makers[msg.Page.Screen]
                if !ok </span><span class="cov0" title="0">{
                        return ReportError(ErrNoMaker)
                }</span>

                <span class="cov0" title="0">var err error
                model, err = maker.Make(msg, 0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return ReportError(err)
                }</span>

                <span class="cov0" title="0">pm.cache.Put(msg.Page, model)
                cmd = model.Init()</span>
        }

        <span class="cov0" title="0">pm.panes[msg.Position] = pane{model: model, page: msg.Page}
        pm.updateChildSizes()

        if !msg.DisableFocus </span><span class="cov0" title="0">{
                pm.focusPane(msg.Position)
        }</span>

        <span class="cov0" title="0">return cmd</span>
}

func (pm *PaneManager) focusPane(position Position) <span class="cov0" title="0">{
        if _, ok := pm.panes[position]; ok </span><span class="cov0" title="0">{
                pm.focused = position
        }</span>
}

func (pm *PaneManager) paneWidth(position Position) int <span class="cov0" title="0">{
        switch position </span>{
        case LeftPane:<span class="cov0" title="0">
                return DefaultLeftPaneWidth</span>
        case BodyPane:<span class="cov0" title="0">
                return pm.width - pm.paneWidth(LeftPane)</span>
        default:<span class="cov0" title="0">
                return pm.width</span>
        }
}

func (pm *PaneManager) paneHeight(_ Position) int <span class="cov0" title="0">{
        return pm.height
}</span>

func (pm *PaneManager) View() string <span class="cov0" title="0">{
        return lipgloss.JoinVertical(lipgloss.Top,
                lipgloss.JoinHorizontal(lipgloss.Top,
                        pm.renderPane(LeftPane),
                        pm.renderPane(BodyPane),
                ),
        )
}</span>

func (pm *PaneManager) renderPane(position Position) string <span class="cov0" title="0">{
        if _, ok := pm.panes[position]; !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Width and Height does not include border size, so substract it
        <span class="cov0" title="0">paneStyle := styles.InactiveBorder.
                Width(pm.paneWidth(position) - borderSize).
                Height(pm.paneHeight(position) - borderSize)

        if position == pm.focused </span><span class="cov0" title="0">{
                paneStyle = styles.ActiveBorder.Inherit(paneStyle)
        }</span>

        <span class="cov0" title="0">model := pm.panes[position].model
        return paneStyle.Render(model.View())</span>

}

func (pm *PaneManager) HelpBindings() (bindings []key.Binding) <span class="cov0" title="0">{
        if model, ok := pm.FocusedModel().(ModelHelpBindings); ok </span><span class="cov0" title="0">{
                bindings = append(bindings, model.HelpBindings()...)
        }</span>
        <span class="cov0" title="0">return bindings</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package tui

import (
        "fmt"
        "gophkeeper/internal/keeper/tui/styles"

        "github.com/charmbracelet/bubbles/key"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// PromptMsg enables the prompt widget.
type PromptMsg struct {
        Prompt       string       // Prompt to display to the user
        Placeholder  string       // Set placeholder text in prompt
        InitialValue string       // Set initial value for the user to edit
        Action       PromptAction // Action to carry out when key is pressed
        Key          key.Binding  // Key that when pressed triggers the action and closes the prompt
        Cancel       key.Binding  // Cancel is a key that when pressed skips the action and closes the prompt
        AnyCancel    bool         // If any key can cancel the prompt
}

type PromptAction func(text string) tea.Cmd

func StringPrompt(prompt string, action PromptAction) tea.Cmd <span class="cov0" title="0">{
        return CmdHandler(PromptMsg{
                Prompt: fmt.Sprintf("%s: ", prompt),
                Action: action,
                Key: key.NewBinding(
                        key.WithKeys("enter"),
                        key.WithHelp("enter", "confirm"),
                ),
                Cancel: key.NewBinding(
                        key.WithKeys("esc"),
                        key.WithHelp("esc", "cancel"),
                ),
                AnyCancel: false,
        })
}</span>

// Yes/No question. If yes is given then the action is invoked.
func YesNoPrompt(prompt string, action tea.Cmd) tea.Cmd <span class="cov0" title="0">{
        return CmdHandler(PromptMsg{
                Prompt: fmt.Sprintf("%s (y/N): ", prompt),
                Action: func(_ string) tea.Cmd </span><span class="cov0" title="0">{
                        return action
                }</span>,
                Key: key.NewBinding(
                        key.WithKeys("y"),
                        key.WithHelp("y", "confirm"),
                ),
                AnyCancel: true,
        })
}

func NewPrompt(msg PromptMsg) (*Prompt, tea.Cmd) <span class="cov0" title="0">{
        model := textinput.New()
        model.Prompt = msg.Prompt
        model.SetValue(msg.InitialValue)
        model.Placeholder = msg.Placeholder
        model.PlaceholderStyle = styles.Regular.Faint(true)
        blink := model.Focus()

        prompt := Prompt{
                model:     model,
                action:    msg.Action,
                trigger:   msg.Key,
                cancel:    msg.Cancel,
                anyCancel: msg.AnyCancel,
        }
        return &amp;prompt, blink
}</span>

// Prompt is a widget that prompts the user for input and triggers an action.
type Prompt struct {
        model     textinput.Model
        action    PromptAction
        trigger   key.Binding
        cancel    key.Binding
        anyCancel bool
}

// HandleKey handles the user key press, and returns a command to be run, and
// whether the prompt should be closed.
func (p *Prompt) HandleKey(msg tea.KeyMsg) (closePrompt bool, cmd tea.Cmd) <span class="cov0" title="0">{
        switch </span>{
        case key.Matches(msg, p.trigger):<span class="cov0" title="0">
                cmd = p.action(p.model.Value())
                closePrompt = true</span>
        case key.Matches(msg, p.cancel), p.anyCancel:<span class="cov0" title="0">
                cmd = ReportInfo("canceled operation")
                closePrompt = true</span>
        default:<span class="cov0" title="0">
                p.model, cmd = p.model.Update(msg)</span>
        }
        <span class="cov0" title="0">return</span>
}

// HandleBlink handles the bubbletea blink message.
func (p *Prompt) HandleBlink(msg tea.Msg) (cmd tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0"></span>
                // Ignore key presses, they're handled by HandleKey above.
        default:<span class="cov0" title="0">
                // The blink message type is unexported so we just send unknown types to the model.
                p.model, cmd = p.model.Update(msg)</span>
        }
        <span class="cov0" title="0">return</span>
}

func (p *Prompt) View(width int) string <span class="cov0" title="0">{
        paddedBorder := styles.ThickBorder.BorderForeground(styles.Red).Padding(0, 1)
        paddedBorderWidth := paddedBorder.GetHorizontalBorderSize() + paddedBorder.GetHorizontalPadding()
        // Set available width for user entered value before it horizontally
        // scrolls.
        p.model.Width = max(0, width-lipgloss.Width(p.model.Prompt)-paddedBorderWidth)
        // Render a prompt, surrounded by a padded red border, spanning the width of the
        // terminal, accounting for width of border. Inline and MaxWidth ensures the
        // prompt remains on a single line.
        content := styles.Regular.Inline(true).MaxWidth(width - paddedBorderWidth).Render(p.model.View())
        return paddedBorder.Width(width - paddedBorder.GetHorizontalBorderSize()).Render(content)
}</span>

func (p *Prompt) HelpBindings() []key.Binding <span class="cov0" title="0">{
        bindings := []key.Binding{
                p.trigger,
        }
        if p.anyCancel </span><span class="cov0" title="0">{
                bindings = append(bindings, key.NewBinding(key.WithHelp("n", "cancel")))
        }</span> else<span class="cov0" title="0"> {
                bindings = append(bindings, p.cancel)
        }</span>
        <span class="cov0" title="0">return bindings</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package blobedit

import (
        "context"
        "errors"
        "fmt"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "os"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

var (
        errTitleEmpty    = errors.New("please enter title")
        errMetadataEmpty = errors.New("please enter metadata")
)

const (
        blobTitle = iota
        blobMetadata
)

type BlobEditScreen struct {
        secret  *models.Secret
        storage storage.Storage

        inputGroup components.InputGroup
}

func (s BlobEditScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewBlobEditScreen(msg.Secret, msg.Storage), nil
}</span>

func NewBlobEditScreen(secret *models.Secret, strg storage.Storage) *BlobEditScreen <span class="cov0" title="0">{
        m := BlobEditScreen{
                secret:  secret,
                storage: strg,
        }

        inputs := make([]textinput.Model, 2)
        inputs[blobTitle] = newInput(inputOpts{placeholder: "Title", charLimit: 64})
        inputs[blobMetadata] = newInput(inputOpts{placeholder: "Metadata", charLimit: 64})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Pick file ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{

                err := m.validateInputs()
                if err != nil </span><span class="cov0" title="0">{
                        return tui.ReportError(err)
                }</span>

                <span class="cov0" title="0">f := func(args ...any) tea.Cmd </span><span class="cov0" title="0">{
                        str, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return tui.ReportError(fmt.Errorf("error opening file"))
                        }</span>

                        <span class="cov0" title="0">err := m.Submit(str)
                        if err != nil </span><span class="cov0" title="0">{
                                return tui.ReportError(fmt.Errorf("error uploading file: %w", err))
                        }</span>

                        <span class="cov0" title="0">return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))</span>
                }

                <span class="cov0" title="0">return tui.SetBodyPane(tui.FilePickScreen, tui.WithStorage(m.storage), tui.WithCallback(f))</span>
        }})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
        }</span>})

        <span class="cov0" title="0">if secret.ID &gt; 0 </span><span class="cov0" title="0">{
                inputs[blobTitle].SetValue(secret.Title)
                inputs[blobMetadata].SetValue(secret.Metadata)
        }</span>

        <span class="cov0" title="0">m.inputGroup = components.NewInputGroup(inputs, buttons)

        return &amp;m</span>
}

func (s BlobEditScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.inputGroup.Init()
}</span>

func (s *BlobEditScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)
}</span>

func (s BlobEditScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in file details:", s.inputGroup.View())
}</span>

func (s BlobEditScreen) validateInputs() error <span class="cov0" title="0">{
        title := s.inputGroup.Inputs[blobTitle].Value()
        metadata := s.inputGroup.Inputs[blobMetadata].Value()

        if len(title) == 0 </span><span class="cov0" title="0">{
                return errTitleEmpty
        }</span>

        <span class="cov0" title="0">if len(metadata) == 0 </span><span class="cov0" title="0">{
                return errMetadataEmpty
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *BlobEditScreen) Submit(path string) error <span class="cov0" title="0">{
        var (
                err error
        )

        err = s.validateInputs()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bts, err := readFileToBytes(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.secret.Title = s.inputGroup.Inputs[blobTitle].Value()
        s.secret.Metadata = s.inputGroup.Inputs[blobMetadata].Value()
        s.secret.Blob = &amp;models.Blob{
                FileName:  path,
                FileBytes: bts,
        }
        s.secret.UpdatedAt = time.Now()

        // Save secret
        if s.secret.ID == 0 </span><span class="cov0" title="0">{
                s.secret.CreatedAt = time.Now()
                err = s.storage.Create(context.Background(), s.secret)
        }</span> else<span class="cov0" title="0"> {
                err = s.storage.Update(context.Background(), s.secret)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func readFileToBytes(filePath string) ([]byte, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package blobedit

import (
        "fmt"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/bubbles/filepicker"
        tea "github.com/charmbracelet/bubbletea"
)

type FilePickScreen struct {
        secret  *models.Secret
        storage storage.Storage

        filePicker filepicker.Model
        callback   tui.NavigationCallback
}

func (s FilePickScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewFilePickScreen(msg.Secret, msg.Storage, msg.Callback), nil
}</span>

func NewFilePickScreen(secret *models.Secret, strg storage.Storage, callback tui.NavigationCallback) *FilePickScreen <span class="cov0" title="0">{
        defaultPath, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                panic("Error getting working directory: %v\n")</span>
        }

        <span class="cov0" title="0">fp := filepicker.New()
        fp.CurrentDirectory = filepath.Join(defaultPath)
        fp.AutoHeight = false
        fp.Height = 10

        m := FilePickScreen{
                filePicker: fp,
                secret:     secret,
                storage:    strg,
                callback:   callback,
        }

        return &amp;m</span>
}

func (s FilePickScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.filePicker.Init()
}</span>

func (s *FilePickScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "b":<span class="cov0" title="0">
                        tui.SetBodyPane(tui.BlobEditScreen, tui.WithStorage(s.storage), tui.WithSecret(s.secret))</span>
                }
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                s.filePicker.Height = msg.Height - styles.FilepickerBotPadding</span>
        }

        <span class="cov0" title="0">s.filePicker, cmd = s.filePicker.Update(msg)
        cmds = append(cmds, cmd)

        if selected, path := s.filePicker.DidSelectFile(msg); selected </span><span class="cov0" title="0">{
                cmds = append(cmds, tui.ReportInfo("selected: %v", path))
                cmds = append(cmds, s.callback(path))
        }</span>

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (s FilePickScreen) View() string <span class="cov0" title="0">{

        var b strings.Builder
        b.WriteString(fmt.Sprintf("%20s%s:\n", "", s.filePicker.CurrentDirectory))
        b.WriteString(s.filePicker.View())

        return screens.RenderContent("Select file to store. Use ←, ↑, →, ↓ to navigate. Press B to go back", b.String())
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package cardedit

import (
        "context"
        "fmt"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "strconv"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

var (
        errFieldEmpty = func(label string) error <span class="cov0" title="0">{ return fmt.Errorf("please enter %s", label) }</span>
)

const (
        cardTitle = iota
        cardMetadata
        cardNumber
        cardExpYear
        cardExpMonth
        cardCVV
)

type CardEditScreen struct {
        secret  *models.Secret
        storage storage.Storage

        inputGroup components.InputGroup
}

func (s CardEditScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewCardEditScreen(msg.Secret, msg.Storage), nil
}</span>

func NewCardEditScreen(secret *models.Secret, strg storage.Storage) *CardEditScreen <span class="cov0" title="0">{
        m := CardEditScreen{
                secret:  secret,
                storage: strg,
        }

        inputs := make([]textinput.Model, 6)
        inputs[cardTitle] = newInput(inputOpts{placeholder: "Title", charLimit: 64})
        inputs[cardMetadata] = newInput(inputOpts{placeholder: "Metadata", charLimit: 64})
        inputs[cardNumber] = newInput(inputOpts{placeholder: "Card number", charLimit: 64})
        inputs[cardExpYear] = newInput(inputOpts{placeholder: "Exp Year", charLimit: 2})
        inputs[cardExpMonth] = newInput(inputOpts{placeholder: "Exp Month", charLimit: 2})
        inputs[cardCVV] = newInput(inputOpts{placeholder: "CVV", charLimit: 6})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Submit ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                err := m.Submit()
                if err != nil </span><span class="cov0" title="0">{
                        return tui.ReportError(err)
                }</span> else<span class="cov0" title="0"> {
                        // todo: invalidate or update cache
                        return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
                }</span>
        }})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
        }</span>})

        <span class="cov0" title="0">if secret.ID &gt; 0 </span><span class="cov0" title="0">{
                inputs[cardTitle].SetValue(secret.Title)
                inputs[cardMetadata].SetValue(secret.Metadata)
                inputs[cardNumber].SetValue(secret.Card.Number)
                inputs[cardExpMonth].SetValue(strconv.FormatUint(uint64(secret.Card.ExpMonth), 10))
                inputs[cardExpYear].SetValue(strconv.FormatUint(uint64(secret.Card.ExpYear), 10))
                inputs[cardCVV].SetValue(strconv.FormatUint(uint64(secret.Card.CVV), 10))
        }</span>

        <span class="cov0" title="0">m.inputGroup = components.NewInputGroup(inputs, buttons)

        return &amp;m</span>
}

func (s CardEditScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.inputGroup.Init()
}</span>

func (s *CardEditScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)
}</span>

func (s *CardEditScreen) Submit() error <span class="cov0" title="0">{
        var (
                err error
        )

        title := s.inputGroup.Inputs[cardTitle].Value()
        metadata := s.inputGroup.Inputs[cardMetadata].Value()
        cardNumber := s.inputGroup.Inputs[cardNumber].Value()
        cardExpMonth := s.inputGroup.Inputs[cardExpMonth].Value()
        cardExpYear := s.inputGroup.Inputs[cardExpYear].Value()
        cardCVV := s.inputGroup.Inputs[cardCVV].Value()

        // Validate inputs
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("metadata")
        }</span>

        <span class="cov0" title="0">if len(title) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("title")
        }</span>

        <span class="cov0" title="0">if len(cardNumber) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("card number")
        }</span>

        <span class="cov0" title="0">if len(cardNumber) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("card number")
        }</span>

        <span class="cov0" title="0">if len(cardExpYear) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("exp year")
        }</span>

        <span class="cov0" title="0">if len(cardExpMonth) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("exp month")
        }</span>

        <span class="cov0" title="0">if len(cardCVV) == 0 </span><span class="cov0" title="0">{
                return errFieldEmpty("CVV")
        }</span>

        <span class="cov0" title="0">s.secret.Title = title
        s.secret.Metadata = metadata
        card := &amp;models.Card{Number: cardNumber}

        card.ExpYear = strToUint32(cardExpYear)
        card.ExpMonth = strToUint32(cardExpMonth)
        card.CVV = strToUint32(cardCVV)

        s.secret.Card = card
        s.secret.UpdatedAt = time.Now()

        // Save secret
        if s.secret.ID == 0 </span><span class="cov0" title="0">{
                s.secret.CreatedAt = time.Now()
                err = s.storage.Create(context.Background(), s.secret)
        }</span> else<span class="cov0" title="0"> {
                err = s.storage.Update(context.Background(), s.secret)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s CardEditScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in card details:", s.inputGroup.View())
}</span>

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}

func strToUint32(str string) uint32 <span class="cov0" title="0">{
        i64, _ := strconv.ParseUint(str, 10, 32)
        return uint32(i64)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package credentialedit

import (
        "context"
        "errors"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

var (
        errMetadataEmpty = errors.New("please enter metadata")
        errLoginEmpty    = errors.New("please enter login")
        errPasswordEmpty = errors.New("please enter password")
        errTitleEmpty    = errors.New("please enter title")
)

const (
        credTitle = iota
        credMetadata
        credLogin
        credPassword
)

type CredentialEditScreen struct {
        secret  *models.Secret
        storage storage.Storage

        inputGroup components.InputGroup
}

func (s CredentialEditScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewCredentialEditScreen(msg.Secret, msg.Storage), nil
}</span>

func NewCredentialEditScreen(secret *models.Secret, strg storage.Storage) *CredentialEditScreen <span class="cov0" title="0">{
        m := CredentialEditScreen{
                secret:  secret,
                storage: strg,
        }

        inputs := make([]textinput.Model, 4)
        inputs[credTitle] = newInput(inputOpts{placeholder: "Title", charLimit: 64})
        inputs[credMetadata] = newInput(inputOpts{placeholder: "Metadata", charLimit: 64})
        inputs[credLogin] = newInput(inputOpts{placeholder: "Login", charLimit: 64})
        inputs[credPassword] = newInput(inputOpts{placeholder: "Password", charLimit: 64})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Submit ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                err := m.Submit()
                if err != nil </span><span class="cov0" title="0">{
                        return tui.ReportError(err)
                }</span> else<span class="cov0" title="0"> {
                        // todo: invalidate or update cache ?
                        return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
                }</span>
        }})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
        }</span>})

        <span class="cov0" title="0">if secret.ID &gt; 0 </span><span class="cov0" title="0">{
                inputs[credTitle].SetValue(secret.Title)
                inputs[credMetadata].SetValue(secret.Metadata)
                inputs[credLogin].SetValue(secret.Creds.Login)
                inputs[credPassword].SetValue(secret.Creds.Password)
        }</span>

        <span class="cov0" title="0">m.inputGroup = components.NewInputGroup(inputs, buttons)

        return &amp;m</span>
}

func (s CredentialEditScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.inputGroup.Init()
}</span>

func (s *CredentialEditScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)
}</span>

func (s *CredentialEditScreen) Submit() error <span class="cov0" title="0">{
        var (
                err error
        )

        title := s.inputGroup.Inputs[credTitle].Value()
        metadata := s.inputGroup.Inputs[credMetadata].Value()
        login := s.inputGroup.Inputs[credLogin].Value()
        password := s.inputGroup.Inputs[credPassword].Value()

        // Validate inputs
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return errMetadataEmpty
        }</span>

        <span class="cov0" title="0">if len(title) == 0 </span><span class="cov0" title="0">{
                return errTitleEmpty
        }</span>

        <span class="cov0" title="0">if len(login) == 0 </span><span class="cov0" title="0">{
                return errLoginEmpty
        }</span>

        <span class="cov0" title="0">if len(password) == 0 </span><span class="cov0" title="0">{
                return errPasswordEmpty
        }</span>

        <span class="cov0" title="0">s.secret.Title = title
        s.secret.Metadata = metadata
        s.secret.Creds = &amp;models.Credentials{Login: login, Password: password}
        s.secret.UpdatedAt = time.Now()

        // Save secret
        if s.secret.ID == 0 </span><span class="cov0" title="0">{
                s.secret.CreatedAt = time.Now()
                err = s.storage.Create(context.Background(), s.secret)
        }</span> else<span class="cov0" title="0"> {
                err = s.storage.Update(context.Background(), s.secret)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s CredentialEditScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in credential details:", s.inputGroup.View())
}</span>

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package login

import (
        "context"
        "errors"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

var (
        errLoginEmpty    = errors.New("please enter login")
        errPasswordEmpty = errors.New("please enter password")
)

const (
        posLogin = iota
        posPassword
)

type Mode int

const (
        modeLogin Mode = iota
        modeRegister
)

type LoginScreen struct {
        client    api.IApiClient
        encrypter crypto.Encrypter

        inputGroup components.InputGroup
}

func (s LoginScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewLoginScreen(msg.Client), nil
}</span>

func NewLoginScreen(client api.IApiClient) *LoginScreen <span class="cov0" title="0">{
        m := LoginScreen{
                client: client,
        }

        inputs := make([]textinput.Model, 2)
        inputs[posLogin] = newInput(inputOpts{placeholder: "Login", charLimit: 64})
        inputs[posPassword] = newInput(inputOpts{placeholder: "Password", charLimit: 64})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Login ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return m.Submit(modeLogin)
        }</span>})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Register ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return m.Submit(modeRegister)
        }</span>})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.GoToStart()
        }</span>})

        <span class="cov0" title="0">m.inputGroup = components.NewInputGroup(inputs, buttons)

        return &amp;m</span>
}

func (s LoginScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.inputGroup.Init()
}</span>

func (s *LoginScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)
}</span>

func (s *LoginScreen) Submit(mode Mode) tea.Cmd <span class="cov0" title="0">{
        var (
                token string
                err   error
                cmds  []tea.Cmd
        )

        login := s.inputGroup.Inputs[posLogin].Value()
        password := s.inputGroup.Inputs[posPassword].Value()

        // Validate inputs
        if len(login) == 0 </span><span class="cov0" title="0">{
                return tui.ReportError(errLoginEmpty)
        }</span>
        <span class="cov0" title="0">if len(password) == 0 </span><span class="cov0" title="0">{
                return tui.ReportError(errPasswordEmpty)
        }</span>

        <span class="cov0" title="0">switch mode </span>{
        case modeLogin:<span class="cov0" title="0">
                token, err = s.client.Login(context.Background(), login, password)</span>
        case modeRegister:<span class="cov0" title="0">
                token, err = s.client.Register(context.Background(), login, password)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                cmds = append(cmds, tui.ReportError(err))
        }</span> else<span class="cov0" title="0"> {
                s.client.SetToken(token)
                s.client.SetPassword(password)

                // create storage instance
                storage, err := storage.NewRemoteStorage(s.client, s.encrypter)
                if err != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, tui.ReportError(err))
                }</span> else<span class="cov0" title="0"> {
                        cmds = append(cmds, tui.ReportInfo("success!"))
                        cmds = append(cmds, tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(storage)))
                }</span>
        }

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (s LoginScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in credentials:", s.inputGroup.View())
}</span>

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package menu

import (
        "fmt"
        "gophkeeper/internal/keeper/tui/styles"
        "io"
        "strings"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

type item string

func (i item) FilterValue() string <span class="cov0" title="0">{ return "" }</span>

type itemDelegate struct{}

func (d itemDelegate) Height() int                             <span class="cov0" title="0">{ return 1 }</span>
func (d itemDelegate) Spacing() int                            <span class="cov0" title="0">{ return 0 }</span>
func (d itemDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd <span class="cov0" title="0">{ return nil }</span>
func (d itemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) <span class="cov0" title="0">{
        var (
                itemStyle         = styles.Regular.PaddingLeft(4)
                selectedItemStyle = styles.Regular.PaddingLeft(2).Foreground(lipgloss.Color("170"))
        )

        i, ok := listItem.(item)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fn := itemStyle.Render
        if index == m.Index() </span><span class="cov0" title="0">{
                fn = func(s ...string) string </span><span class="cov0" title="0">{
                        return selectedItemStyle.Render("&gt; " + strings.Join(s, " "))
                }</span>
        }

        <span class="cov0" title="0">_, _ = fmt.Fprint(w, fn(string(i)))</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package menu

import (
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/styles"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

var (
        menuItems = []MenuItem{
                {name: "Welcome", cmd: tui.GoToStart()},
                {name: "Open local storage", cmd: tui.SetBodyPane(tui.StorageOpenScreen)},
                {name: "Create local storage", cmd: tui.SetBodyPane(tui.StorageCreateScreen)},
                {name: "Open remote storage", cmd: tui.SetBodyPane(tui.RemoteOpenScreen)},
        }
)

type MenuItem struct {
        name string
        cmd  tea.Cmd
}

type MenuScreen struct {
        tea.Model

        list list.Model

        width  int
        height int

        choice    string
        menuItems []MenuItem
        itemsMap  map[string]int
}

func (s MenuScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewMenu(width, height), nil
}</span>

func NewMenu(width, height int) *MenuScreen <span class="cov0" title="0">{
        m := MenuScreen{
                itemsMap: make(map[string]int, len(menuItems)),
                width:    width,
                height:   height,
        }

        m.prepareMenuModel(menuItems)

        return &amp;m
}</span>

func (s MenuScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (s *MenuScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                s.list.SetWidth(msg.Width)
                s.list.SetHeight(len(s.itemsMap))

                s.width = msg.Width
                s.height = msg.Height</span>
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "enter":<span class="cov0" title="0">
                        i, ok := s.list.SelectedItem().(item)
                        if ok </span><span class="cov0" title="0">{
                                s.choice = string(i)
                                idx := s.itemsMap[string(i)]
                                cmds = append(cmds, menuItems[idx].cmd)
                        }</span>
                }
        }

        <span class="cov0" title="0">s.list, cmd = s.list.Update(msg)
        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)</span>
}

func (s MenuScreen) View() string <span class="cov0" title="0">{
        return lipgloss.Place(
                s.width, s.height,
                lipgloss.Center, lipgloss.Center,
                styles.Regular.Render(s.list.View()),
        )
}</span>

func (s *MenuScreen) prepareMenuModel(menuItems []MenuItem) <span class="cov0" title="0">{
        listItems := []list.Item{}
        for i, menuItem := range menuItems </span><span class="cov0" title="0">{
                listItems = append(listItems, item(menuItem.name))
                s.itemsMap[menuItem.name] = i // for ease of search
        }</span>

        <span class="cov0" title="0">s.list = list.New(listItems, itemDelegate{}, 0, 0)

        s.list.SetShowStatusBar(false)
        s.list.SetFilteringEnabled(false)
        s.list.SetShowTitle(false)
        s.list.SetShowPagination(false)
        s.list.SetShowHelp(false)
        s.list.KeyMap.Quit.SetEnabled(false)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package remoteeopen

import (
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"

        tea "github.com/charmbracelet/bubbletea"
)

type RemoteOpenScreen struct {
        client api.IApiClient
}

type RemoteOpenScreenMaker struct {
        Client api.IApiClient
}

func (m RemoteOpenScreenMaker) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewRemoteOpenScreen(m.Client), nil
}</span>

func (s RemoteOpenScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewRemoteOpenScreen(msg.Client), nil
}</span>

func NewRemoteOpenScreen(client api.IApiClient) *RemoteOpenScreen <span class="cov0" title="0">{
        return &amp;RemoteOpenScreen{
                client: client,
        }
}</span>

func (s RemoteOpenScreen) Init() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd

        if len(s.client.GetToken()) &gt; 0 </span><span class="cov0" title="0">{
                // already authorized
                encrypter := crypto.NewKeeperEncrypter()
                strg, err := storage.NewRemoteStorage(s.client, encrypter)
                if err != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, tui.ReportError(err))
                }</span> else<span class="cov0" title="0"> {
                        cmds = append(cmds, tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(strg)))
                }</span>
        } else<span class="cov0" title="0"> {
                // go to login
                cmds = append(cmds, tui.SetBodyPane(tui.LoginScreen, tui.WithClient(s.client)))
        }</span>

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (s *RemoteOpenScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (s RemoteOpenScreen) View() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package screens

import (
        "gophkeeper/internal/keeper/tui/styles"
        "strings"
)

func RenderContent(header, content string) string <span class="cov0" title="0">{
        var b strings.Builder

        b.WriteString(styles.HeaderStyle.Render(header))
        b.WriteString("\n\n")
        b.WriteString(content)

        return styles.ContentPaddedStyle.Render(b.String())
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package secrettype

import (
        "fmt"
        "gophkeeper/internal/keeper/tui/styles"
        "io"
        "strings"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

type secretItem struct {
        id   int
        name string
}

func (i secretItem) FilterValue() string <span class="cov0" title="0">{ return "" }</span>

type secretItemDelegate struct{}

func (d secretItemDelegate) Height() int                             <span class="cov0" title="0">{ return 1 }</span>
func (d secretItemDelegate) Spacing() int                            <span class="cov0" title="0">{ return 0 }</span>
func (d secretItemDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd <span class="cov0" title="0">{ return nil }</span>
func (d secretItemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) <span class="cov0" title="0">{
        var (
                itemStyle         = styles.Regular.PaddingLeft(4)
                itemSelectedStyle = styles.Regular.PaddingLeft(2).Foreground(lipgloss.Color("170"))
        )

        i, ok := listItem.(secretItem)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fn := itemStyle.Render
        if index == m.Index() </span><span class="cov0" title="0">{
                fn = func(s ...string) string </span><span class="cov0" title="0">{
                        return itemSelectedStyle.Render("&gt; " + strings.Join(s, " "))
                }</span>
        }

        <span class="cov0" title="0">_, _ = fmt.Fprint(w, fn(string(i.name)))</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package secrettype

import (
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/pkg/models"
        "maps"
        "slices"
        "sort"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
)

const (
        selectBack = iota
        selectCredential
        selectText
        selectCard
        selectBlob
)

// Model which renders selection list of different commands
type SecretTypeScreen struct {
        tea.Model

        storage storage.Storage

        list   list.Model
        choice string
}

func (s SecretTypeScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewSecretTypeScreen(msg.Storage), nil
}</span>

func NewSecretTypeScreen(strg storage.Storage) *SecretTypeScreen <span class="cov0" title="0">{
        m := &amp;SecretTypeScreen{storage: strg}
        m.prepareSecretListModel()

        return m
}</span>

func (s *SecretTypeScreen) prepareSecretListModel() <span class="cov0" title="0">{
        choices := map[int]string{
                selectBack:       "Go back",
                selectCredential: "Add credentials",
                selectText:       "Add text",
                selectCard:       "Add card info",
                selectBlob:       "Upload file",
        }

        keys := slices.Collect(maps.Keys(choices))
        sort.Ints(keys)

        items := []list.Item{}
        for i := range keys </span><span class="cov0" title="0">{
                items = append(items, secretItem{id: i, name: choices[i]})
        }</span>

        <span class="cov0" title="0">l := list.New(items, secretItemDelegate{}, 0, 0)
        l.SetShowStatusBar(false)
        l.SetFilteringEnabled(false)
        l.SetShowTitle(false)
        l.SetShowPagination(false)
        l.SetShowHelp(false)
        l.KeyMap.Quit.SetEnabled(false)

        s.list = l</span>
}

func (s SecretTypeScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.SetWindowTitle("GophKeeper client")
}</span>

func (s *SecretTypeScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0"> // pane size
                s.list.SetWidth(msg.Width)
                s.list.SetHeight(msg.Height - 2 - 2)</span>
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "enter":<span class="cov0" title="0">

                        i, ok := s.list.SelectedItem().(secretItem)
                        if ok </span><span class="cov0" title="0">{
                                s.choice = string(i.name)
                                // cmds = append(cmds, s.items[string(i)].cmd)
                        }</span>

                        <span class="cov0" title="0">switch i.id </span>{
                        case selectBack:<span class="cov0" title="0">
                                cmd = tui.SetBodyPane(
                                        tui.StorageBrowseScreen,
                                        tui.WithStorage(s.storage),
                                )

                                return cmd</span>

                        case selectCredential:<span class="cov0" title="0">
                                sec := models.NewSecret(models.CredSecret)

                                cmd = tui.SetBodyPane(
                                        tui.CredentialEditScreen,
                                        tui.WithStorage(s.storage),
                                        tui.WithSecret(sec),
                                )</span>
                        case selectText:<span class="cov0" title="0">
                                sec := models.NewSecret(models.TextSecret)

                                cmd = tui.SetBodyPane(
                                        tui.TextEditScreen,
                                        tui.WithStorage(s.storage),
                                        tui.WithSecret(sec),
                                )</span>
                        case selectCard:<span class="cov0" title="0">
                                sec := models.NewSecret(models.CardSecret)

                                cmd = tui.SetBodyPane(
                                        tui.CardEditScreen,
                                        tui.WithStorage(s.storage),
                                        tui.WithSecret(sec),
                                )</span>
                        case selectBlob:<span class="cov0" title="0">
                                sec := models.NewSecret(models.BlobSecret)

                                cmd = tui.SetBodyPane(
                                        tui.BlobEditScreen,
                                        tui.WithStorage(s.storage),
                                        tui.WithSecret(sec),
                                )</span>
                        }

                        <span class="cov0" title="0">cmds = append(cmds, cmd)</span>
                }
        }

        <span class="cov0" title="0">s.list, cmd = s.list.Update(msg)
        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)</span>
}

func (s *SecretTypeScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Select type of secret:", s.list.View())
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package storagebrowse

import (
        "context"
        "fmt"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "os"
        "sort"
        "strconv"
        "strings"

        "github.com/atotto/clipboard"
        "github.com/charmbracelet/bubbles/key"
        "github.com/charmbracelet/bubbles/table"
        tea "github.com/charmbracelet/bubbletea"
)

const (
        tableBorderSize = 4
)

type savePathMsg = struct {
        path   string
        secret *models.Secret
}

type StorageBrowseScreen struct {
        storage storage.Storage
        table   table.Model
}

func (s StorageBrowseScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewStorageBrowseScreenScreen(msg.Storage), nil
}</span>

func NewStorageBrowseScreenScreen(strg storage.Storage) *StorageBrowseScreen <span class="cov0" title="0">{
        scr := &amp;StorageBrowseScreen{
                storage: strg,
                table:   prepareTable(),
        }

        scr.updateRows()

        return scr
}</span>

func (s StorageBrowseScreen) Init() tea.Cmd <span class="cov0" title="0">{
        s.updateRows()
        return nil
}</span>

func (s *StorageBrowseScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case savePathMsg:<span class="cov0" title="0"> // msg from prompt for blob-secret copy-hotkey
                err := os.WriteFile(msg.path, msg.secret.Blob.FileBytes, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, tui.ReportError(err))
                }</span> else<span class="cov0" title="0"> {
                        cmds = append(cmds, infoCmd("file saved successfully"))
                }</span>
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                s.table.SetWidth(min(msg.Width, s.colsWidth()))
                s.table.SetHeight(msg.Height - tableBorderSize)</span>
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "a":<span class="cov0" title="0"> // add
                        cmd = tui.SetBodyPane(tui.SecretTypeScreen, tui.WithStorage(s.storage))
                        cmds = append(cmds, cmd)</span>
                case "e", "enter":<span class="cov0" title="0"> // edit
                        cmds = append(cmds, s.handleEdit())</span>
                case "c":<span class="cov0" title="0">
                        cmds = append(cmds, s.handleCopy())</span>
                case "d":<span class="cov0" title="0"> // delete
                        cmds = append(cmds, s.handleDelete())

                        // update table
                        s.updateRows()
                        cmds = append(cmds, tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(s.storage)))</span>
                }
        }

        <span class="cov0" title="0">s.table.Focus()
        s.table, cmd = s.table.Update(msg)
        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)</span>
}

func (s StorageBrowseScreen) View() string <span class="cov0" title="0">{
        var b strings.Builder

        b.WriteString(fmt.Sprintf("Operating storage %s\n", styles.Highlighted.Render(s.storage.String())))
        b.WriteString("Use ↑↓ to navigate, (a)dd, (e)dit, (d)elete, (c)opy\n")
        b.WriteString(tableStyle.Render(s.table.View()))

        return screenStyle.Render(b.String())
}</span>

func (s *StorageBrowseScreen) HelpBindings() []key.Binding <span class="cov0" title="0">{
        return []key.Binding{
                key.NewBinding(key.WithKeys("a"), key.WithHelp("a", "add secret")),
                key.NewBinding(key.WithKeys("e"), key.WithHelp("e", "edit secret")),
                key.NewBinding(key.WithKeys("d"), key.WithHelp("d", "delete secret")),
                key.NewBinding(key.WithKeys("c"), key.WithHelp("c", "copy/save secret")),
        }
}</span>

func (s *StorageBrowseScreen) updateRows() <span class="cov0" title="0">{
        secrets, _ := s.storage.GetAll(context.Background())

        sortSecrets(secrets)

        rows := []table.Row{}
        for _, sec := range secrets </span><span class="cov0" title="0">{
                rows = append(rows, table.Row{
                        strconv.Itoa(int(sec.ID)),
                        sec.Title,
                        sec.SecretType,
                        sec.CreatedAt.Format("02 Jan 06 15:04"),
                        sec.UpdatedAt.Format("02 Jan 06 15:04"),
                })
        }</span>

        <span class="cov0" title="0">s.table.SetRows(rows)</span>
}

func (s StorageBrowseScreen) handleEdit() tea.Cmd <span class="cov0" title="0">{
        secret, err := s.getSelectedSecret()
        if err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to load secret: %w", err)
        }</span>

        <span class="cov0" title="0">screen, err := s.getScreenForSecret(secret)
        if err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to get screen: %w", err)
        }</span>

        <span class="cov0" title="0">return tui.SetBodyPane(screen, tui.WithSecret(secret), tui.WithStorage(s.storage))</span>
}

func (s StorageBrowseScreen) handleCopy() tea.Cmd <span class="cov0" title="0">{
        secret, err := s.getSelectedSecret()
        if err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to load secret: %w", err)
        }</span>

        <span class="cov0" title="0">if secret.SecretType == string(models.BlobSecret) </span><span class="cov0" title="0">{
                // prompt and save file
                return tui.StringPrompt("choose path to save", func(str string) tea.Cmd </span><span class="cov0" title="0">{ return func() tea.Msg </span><span class="cov0" title="0">{ return savePathMsg{path: str, secret: secret} }</span> })
        }

        <span class="cov0" title="0">if err := clipboard.WriteAll(secret.ToClipboard()); err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to copy to clipboard: %w", err)
        }</span>

        <span class="cov0" title="0">return infoCmd("secret copied successfully")</span>
}

func (s StorageBrowseScreen) handleDelete() tea.Cmd <span class="cov0" title="0">{
        secret, err := s.getSelectedSecret()
        if err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to load secret", err)
        }</span>

        <span class="cov0" title="0">err = s.storage.Delete(context.Background(), secret.ID)
        if err != nil </span><span class="cov0" title="0">{
                return errCmd("failed to delete secret", err)
        }</span>

        <span class="cov0" title="0">return infoCmd("secret deleted")</span>
}

func errCmd(msg string, err error) tea.Cmd <span class="cov0" title="0">{
        return tui.ReportError(fmt.Errorf("%s: %w", msg, err))
}</span>

func infoCmd(msg string) tea.Cmd <span class="cov0" title="0">{
        return tui.ReportInfo("%s", msg)
}</span>

func (s StorageBrowseScreen) getSelectedSecret() (secret *models.Secret, err error) <span class="cov0" title="0">{
        row := s.table.SelectedRow()

        secret, err = s.loadSecret(row[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return secret, err</span>
}

func (s StorageBrowseScreen) loadSecret(rawID string) (*models.Secret, error) <span class="cov0" title="0">{
        var err error

        id, err := strconv.ParseUint(rawID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sec, err := s.storage.Get(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sec, err</span>
}

func (s StorageBrowseScreen) getScreenForSecret(secret *models.Secret) (tui.Screen, error) <span class="cov0" title="0">{
        switch secret.SecretType </span>{
        case string(models.CredSecret):<span class="cov0" title="0">
                return tui.CredentialEditScreen, nil</span>
        case string(models.TextSecret):<span class="cov0" title="0">
                return tui.TextEditScreen, nil</span>
        case string(models.BlobSecret):<span class="cov0" title="0">
                return tui.BlobEditScreen, nil</span>
        case string(models.CardSecret):<span class="cov0" title="0">
                return tui.CardEditScreen, nil</span>
        default:<span class="cov0" title="0">
                return -1, fmt.Errorf("unknown secret type")</span>
        }
}

func (s StorageBrowseScreen) colsWidth() int <span class="cov0" title="0">{
        cols := s.table.Columns()
        total := tableBorderSize
        for _, c := range cols </span><span class="cov0" title="0">{
                total += c.Width
        }</span>

        <span class="cov0" title="0">return total</span>
}

func sortSecrets(secrets []*models.Secret) <span class="cov0" title="0">{
        sort.Slice(secrets, func(i, j int) bool </span><span class="cov0" title="0">{
                return secrets[i].UpdatedAt.After(secrets[j].UpdatedAt) // UpdatedAt desc
        }</span>)
}

func prepareTable() table.Model <span class="cov0" title="0">{
        columns := []table.Column{
                {Title: "id", Width: 5},
                {Title: "Title", Width: 20},
                {Title: "SecretType", Width: 20},
                {Title: "Created", Width: 20},
                {Title: "Updated", Width: 20},
        }

        t := table.New(
                table.WithColumns(columns),
                table.WithFocused(true),
        )

        st := table.DefaultStyles()
        st.Header = tableHeaderStyle
        st.Selected = tableSelectedStyle
        t.SetStyles(st)

        return t
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package storagecreate

import (
        "fmt"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/internal/keeper/usecase"
        "os"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

const (
        createPath = iota
        createPassword
)

type storageCreatedMsg struct{}

type StorageCreateScreen struct {
        inputGroup components.InputGroup

        pathInput     textinput.Model
        passwordInput textinput.Model

        storage   storage.Storage
        encrypter crypto.Encrypter

        createStorageUC *usecase.CreateLocalStoreUseCase
}

func (s StorageCreateScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewStorageCreateScreen()
}</span>

func NewStorageCreateScreen() (*StorageCreateScreen, error) <span class="cov0" title="0">{
        var err error

        hdir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home dir: %s", err.Error())
        }</span>

        <span class="cov0" title="0">scr := &amp;StorageCreateScreen{
                encrypter:       crypto.NewKeeperEncrypter(),
                createStorageUC: usecase.NewCreateStorageUsecase(),
        }

        inputs := make([]textinput.Model, 2)
        inputs[createPath] = newInput(inputOpts{placeholder: "Path to store", charLimit: 256, value: fmt.Sprintf("%s/%s", hdir, "secret.db")})
        inputs[createPassword] = newInput(inputOpts{placeholder: "Password", charLimit: 64})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Submit ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return scr.Submit()
        }</span>})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.GoToStart()
        }</span>})

        <span class="cov0" title="0">scr.inputGroup = components.NewInputGroup(inputs, buttons)

        return scr, err</span>
}

func (s StorageCreateScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

func (s *StorageCreateScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)
        return tea.Batch(cmds...)
}</span>

func (s StorageCreateScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in storage details: \n", s.inputGroup.View())
}</span>

func (s *StorageCreateScreen) Submit() tea.Cmd <span class="cov0" title="0">{
        var (
                err  error
                cmds []tea.Cmd
        )

        path := s.inputGroup.Inputs[createPath].Value()
        password := s.inputGroup.Inputs[createPassword].Value()

        // TODO: validate inputs

        s.storage, err = s.createStorageUC.Call(path, password, s.encrypter)
        if err != nil </span><span class="cov0" title="0">{
                cmds = append(cmds, tui.ReportInfo("Error: %v", err))
        }</span> else<span class="cov0" title="0"> {
                cmds = append(cmds, tui.ReportInfo("Created new storage: %v", path))
                cmds = append(cmds, tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(s.storage)))
        }</span>

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
        value       string
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if len(opts.value) &gt; 0 </span><span class="cov0" title="0">{
                t.SetValue(opts.value)
        }</span>

        <span class="cov0" title="0">if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package storageopen

import (
        "fmt"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/bubbles/filepicker"
        tea "github.com/charmbracelet/bubbletea"
)

type passwordProvidedMsg struct {
        path     string
        password string
}

type StorageOpenScreen struct {
        filePicker filepicker.Model
        encrypter  crypto.Encrypter
        selected   string
}

func (s StorageOpenScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewStorageOpenScreen(), nil
}</span>

func NewStorageOpenScreen() *StorageOpenScreen <span class="cov0" title="0">{
        defaultPath, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                panic("Error getting working directory: %v\n")</span>
        }

        <span class="cov0" title="0">fp := filepicker.New()
        fp.CurrentDirectory = filepath.Join(defaultPath)
        fp.AutoHeight = false
        fp.Height = 10 // default height

        return &amp;StorageOpenScreen{
                filePicker: fp,
                encrypter:  crypto.NewKeeperEncrypter(),
        }</span>
}

func (s StorageOpenScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.filePicker.Init()
}</span>

func (s *StorageOpenScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        switch msg := msg.(type) </span>{
        case passwordProvidedMsg:<span class="cov0" title="0"> // msg from prompt for password
                strg, err := storage.NewFileStorage(msg.path, msg.password, s.encrypter)
                if err != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, tui.ReportError(err))
                }</span> else<span class="cov0" title="0"> {
                        cmd = tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(strg))
                        cmds = append(cmds, cmd)
                }</span>
        default:<span class="cov0" title="0">
                s.filePicker, cmd = s.filePicker.Update(msg)
                cmds = append(cmds, cmd)

                if selected, path := s.filePicker.DidSelectFile(msg); selected </span><span class="cov0" title="0">{
                        return tui.StringPrompt("enter password", func(str string) tea.Cmd </span><span class="cov0" title="0">{
                                return func() tea.Msg </span><span class="cov0" title="0">{ return passwordProvidedMsg{path: path, password: str} }</span>
                        })
                }
        }

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "b":<span class="cov0" title="0">
                        cmds = append(cmds, tui.GoToStart())</span>
                }
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                s.filePicker.Height = msg.Height - styles.FilepickerBotPadding</span>
        }

        <span class="cov0" title="0">cmds = append(cmds, cmd)
        return tea.Batch(cmds...)</span>
}

func (s StorageOpenScreen) View() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(fmt.Sprintf("%20s%s:\n", "", s.filePicker.CurrentDirectory))
        b.WriteString(s.filePicker.View())

        return screens.RenderContent("Select storage file to open. Use ←, ↑, →, ↓ to navigate", b.String())
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package textedit

import (
        "context"
        "errors"
        "gophkeeper/internal/keeper/storage"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/components"
        "gophkeeper/internal/keeper/tui/screens"
        "gophkeeper/internal/keeper/tui/styles"
        "gophkeeper/pkg/models"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

var (
        errMetadataEmpty = errors.New("please enter metadata")
        errContentEmpty  = errors.New("please enter content")
        errTitleEmpty    = errors.New("please enter title")
)

const (
        textTitle = iota
        textMetadata
        textContent
)

type TextEditScreen struct {
        secret  *models.Secret
        storage storage.Storage

        inputGroup components.InputGroup
}

func (s TextEditScreen) Make(msg tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewTextEditScreen(msg.Secret, msg.Storage), nil
}</span>

func NewTextEditScreen(secret *models.Secret, strg storage.Storage) *TextEditScreen <span class="cov0" title="0">{
        m := TextEditScreen{
                secret:  secret,
                storage: strg,
        }

        inputs := make([]textinput.Model, 3)
        inputs[textTitle] = newInput(inputOpts{placeholder: "Title", charLimit: 64})
        inputs[textMetadata] = newInput(inputOpts{placeholder: "Metadata", charLimit: 64})
        inputs[textContent] = newInput(inputOpts{placeholder: "Content", charLimit: 164})

        buttons := []components.Button{}
        buttons = append(buttons, components.Button{Title: "[ Submit ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                err := m.Submit()
                if err != nil </span><span class="cov0" title="0">{
                        return tui.ReportError(err)
                }</span> else<span class="cov0" title="0"> {
                        // todo: invalidate or update cache ?
                        return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
                }</span>
        }})

        <span class="cov0" title="0">buttons = append(buttons, components.Button{Title: "[ Back ]", Cmd: func() tea.Cmd </span><span class="cov0" title="0">{
                return tui.SetBodyPane(tui.StorageBrowseScreen, tui.WithStorage(m.storage))
        }</span>})

        <span class="cov0" title="0">if secret.ID &gt; 0 </span><span class="cov0" title="0">{
                inputs[textTitle].SetValue(secret.Title)
                inputs[textMetadata].SetValue(secret.Metadata)
                inputs[textContent].SetValue(secret.Text.Content)

        }</span>

        <span class="cov0" title="0">m.inputGroup = components.NewInputGroup(inputs, buttons)

        return &amp;m</span>
}

func (s TextEditScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return s.inputGroup.Init()
}</span>

func (s *TextEditScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        var (
                cmd  tea.Cmd
                cmds []tea.Cmd
        )

        // Handle input group. TODO: fix blink
        ig, cmd := s.inputGroup.Update(msg)
        s.inputGroup = ig.(components.InputGroup)

        cmds = append(cmds, cmd)

        return tea.Batch(cmds...)
}</span>

func (s *TextEditScreen) Submit() error <span class="cov0" title="0">{
        var (
                err error
        )

        title := s.inputGroup.Inputs[textTitle].Value()
        metadata := s.inputGroup.Inputs[textMetadata].Value()
        content := s.inputGroup.Inputs[textContent].Value()

        // Validate inputs
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return errMetadataEmpty
        }</span>

        <span class="cov0" title="0">if len(title) == 0 </span><span class="cov0" title="0">{
                return errTitleEmpty
        }</span>

        <span class="cov0" title="0">if len(content) == 0 </span><span class="cov0" title="0">{
                return errContentEmpty
        }</span>

        <span class="cov0" title="0">s.secret.Title = title
        s.secret.Metadata = metadata
        s.secret.Text = &amp;models.Text{Content: content}
        s.secret.UpdatedAt = time.Now()

        // Save secret
        if s.secret.ID == 0 </span><span class="cov0" title="0">{
                s.secret.CreatedAt = time.Now()
                err = s.storage.Create(context.Background(), s.secret)
        }</span> else<span class="cov0" title="0"> {
                err = s.storage.Update(context.Background(), s.secret)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s TextEditScreen) View() string <span class="cov0" title="0">{
        return screens.RenderContent("Fill in text details:", s.inputGroup.View())
}</span>

type inputOpts struct {
        placeholder string
        charLimit   int
        focus       bool
}

func newInput(opts inputOpts) textinput.Model <span class="cov0" title="0">{
        t := textinput.New()
        t.CharLimit = opts.charLimit
        t.Placeholder = opts.placeholder

        if opts.focus </span><span class="cov0" title="0">{
                t.Focus()
                t.PromptStyle = styles.Focused
                t.TextStyle = styles.Focused
        }</span>

        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package welcome

import (
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/styles"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

const (
        logo = `
   _____             _     _  __                         
  / ____|           | |   | |/ /                         
 | |  __  ___  _ __ | |__ | ' / ___  ___ _ __   ___ _ __ 
 | | |_ |/ _ \| '_ \| '_ \|  &lt; / _ \/ _ \ '_ \ / _ \ '__|
 | |__| | (_) | |_) | | | | . \  __/  __/ |_) |  __/ |   
  \_____|\___/| .__/|_| |_|_|\_\___|\___| .__/ \___|_|   
              | |                       | |              
              |_|                       |_|              
        `
)

type WelcomeScreen struct {
        width, height int
}

func (s WelcomeScreen) Make(_ tui.NavigationMsg, width, height int) (tui.Teable, error) <span class="cov0" title="0">{
        return NewWelcomeScreen(width, height), nil
}</span>

func NewWelcomeScreen(width, height int) *WelcomeScreen <span class="cov0" title="0">{
        return &amp;WelcomeScreen{
                width:  width,
                height: height,
        }
}</span>

func (s WelcomeScreen) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.SetWindowTitle("GophKeeper client")
}</span>

func (s *WelcomeScreen) Update(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                s.width = msg.Width
                s.height = msg.Height</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s WelcomeScreen) View() string <span class="cov0" title="0">{
        return lipgloss.Place(
                s.width, s.height,
                lipgloss.Center, lipgloss.Center,
                styles.Highlighted.Render(logo),
        )
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package top

import (
        "gophkeeper/internal/keeper/tui"

        blobEdit "gophkeeper/internal/keeper/tui/screens/blob_edit"
        cardEdit "gophkeeper/internal/keeper/tui/screens/card_edit"
        credentialEdit "gophkeeper/internal/keeper/tui/screens/credential_edit"
        "gophkeeper/internal/keeper/tui/screens/login"
        "gophkeeper/internal/keeper/tui/screens/menu"
        remoteeopen "gophkeeper/internal/keeper/tui/screens/remote_open"
        secretType "gophkeeper/internal/keeper/tui/screens/secret_type"
        storageBrowse "gophkeeper/internal/keeper/tui/screens/storage_browse"
        storageCreate "gophkeeper/internal/keeper/tui/screens/storage_create"
        storageOpen "gophkeeper/internal/keeper/tui/screens/storage_open"
        textEdit "gophkeeper/internal/keeper/tui/screens/text_edit"
        "gophkeeper/internal/keeper/tui/screens/welcome"
)

// Screen constructors. Inject dependencies if any
func prepareMakers(deps ModelDependencies) map[tui.Screen]tui.ScreenMaker <span class="cov0" title="0">{
        return map[tui.Screen]tui.ScreenMaker{
                tui.WelcomeScreen:        &amp;welcome.WelcomeScreen{},
                tui.MenuScreen:           &amp;menu.MenuScreen{},
                tui.StorageCreateScreen:  &amp;storageCreate.StorageCreateScreen{},
                tui.StorageOpenScreen:    &amp;storageOpen.StorageOpenScreen{},
                tui.StorageBrowseScreen:  &amp;storageBrowse.StorageBrowseScreen{},
                tui.SecretTypeScreen:     &amp;secretType.SecretTypeScreen{},
                tui.CredentialEditScreen: &amp;credentialEdit.CredentialEditScreen{},
                tui.TextEditScreen:       &amp;textEdit.TextEditScreen{},
                tui.CardEditScreen:       &amp;cardEdit.CardEditScreen{},
                tui.BlobEditScreen:       &amp;blobEdit.BlobEditScreen{},
                tui.FilePickScreen:       &amp;blobEdit.FilePickScreen{},
                tui.LoginScreen:          &amp;login.LoginScreen{},
                tui.RemoteOpenScreen:     &amp;remoteeopen.RemoteOpenScreenMaker{Client: deps.Client},
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package top

import (
        "fmt"
        "gophkeeper/internal/keeper/api"
        "gophkeeper/internal/keeper/config"
        "gophkeeper/internal/keeper/tui"
        "gophkeeper/internal/keeper/tui/styles"
        "reflect"
        "strings"

        "github.com/charmbracelet/bubbles/cursor"
        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "go.uber.org/dig"
)

type mode int

const (
        normalMode mode = iota // default
        promptMode             // prompt is visible
)

var (
        helpStyle    = styles.Padded.Background(styles.Grey).Foreground(styles.White)
        versionStyle = styles.Padded.Background(styles.DarkGrey).Foreground(styles.White)
)

// Top-level tea model
type Model struct {
        *tui.PaneManager

        config *config.Config
        client api.IApiClient
        makers map[tui.Screen]tui.ScreenMaker
        prompt *tui.Prompt
        mode   mode

        width    int
        height   int
        showHelp bool
        err      error
        info     string

        helpWidget, versionWidget string
}

type ModelDependencies struct {
        dig.In

        Config *config.Config
        Client api.IApiClient
}

func NewModel(deps ModelDependencies) (*Model, error) <span class="cov0" title="0">{
        makers := prepareMakers(deps)

        m := Model{
                config:        deps.Config,
                client:        deps.Client,
                PaneManager:   tui.NewPaneManager(makers),
                makers:        makers,
                helpWidget:    helpStyle.Render(fmt.Sprintf("%s for help", tui.GlobalKeys.Help.Help().Key)),
                versionWidget: versionStyle.Render(fmt.Sprintf("%s (%s)", deps.Config.BuildVersion, deps.Config.BuildDate)),
        }

        return &amp;m, nil
}</span>

func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return m.PaneManager.Init()
}</span>

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tui.PromptMsg:<span class="cov0" title="0">
                m.mode = promptMode
                var blink tea.Cmd
                m.prompt, blink = tui.NewPrompt(msg)

                // Tell panes to resize themselves
                cmd := m.PaneManager.Update(tea.WindowSizeMsg{
                        Height: m.viewHeight(),
                        Width:  m.viewWidth(),
                })

                return m, tea.Batch(cmd, blink)</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                m.info = "" // Clear info/error messages in the footer
                m.err = nil

                switch m.mode </span>{
                case promptMode:<span class="cov0" title="0">
                        closePrompt, cmd := m.prompt.HandleKey(msg)
                        if closePrompt </span><span class="cov0" title="0">{
                                m.mode = normalMode
                                m.PaneManager.Update(tea.WindowSizeMsg{
                                        Height: m.viewHeight(),
                                        Width:  m.viewWidth(),
                                })
                        }</span>
                        <span class="cov0" title="0">return m, cmd</span>
                }

                <span class="cov0" title="0">switch </span>{
                case key.Matches(msg, tui.GlobalKeys.Quit):<span class="cov0" title="0">
                        return m, tui.YesNoPrompt("Quit?", tea.Quit)</span>
                case key.Matches(msg, tui.GlobalKeys.Help):<span class="cov0" title="0">
                        m.showHelp = !m.showHelp

                        m.PaneManager.Update(tea.WindowSizeMsg{
                                Height: m.viewHeight(),
                                Width:  m.viewWidth(),
                        })</span>

                default:<span class="cov0" title="0">
                        // Send all other keys to panes
                        return m, m.PaneManager.Update(msg)</span>
                }

        case tui.ErrorMsg:<span class="cov0" title="0">
                m.err = error(msg)</span>

        case tui.InfoMsg:<span class="cov0" title="0">
                m.info = string(msg)</span>

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height

                m.PaneManager.Update(tea.WindowSizeMsg{
                        Height: m.viewHeight(),
                        Width:  m.viewWidth(),
                })</span>

        case cursor.BlinkMsg:<span class="cov0" title="0">
                var cmd tea.Cmd
                if m.mode == promptMode </span><span class="cov0" title="0">{
                        cmd = m.prompt.HandleBlink(msg)
                }</span> else<span class="cov0" title="0"> {
                        cmd = m.PaneManager.FocusedModel().Update(msg)
                }</span>
                <span class="cov0" title="0">return m, cmd</span>
        default:<span class="cov0" title="0">
                // Send remaining msg types to pane manager
                cmds = append(cmds, m.PaneManager.Update(msg))</span>
        }

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

func (m Model) View() string <span class="cov0" title="0">{
        var components []string

        // Add prompt if in prompt mode
        if m.mode == promptMode </span><span class="cov0" title="0">{
                components = append(components, m.prompt.View(m.width))
        }</span>

        // Add pane manager
        <span class="cov0" title="0">components = append(components, styles.Regular.
                Height(m.viewHeight()).
                Width(m.viewWidth()).
                Render(m.PaneManager.View()),
        )

        // Add help if enabled
        if m.showHelp </span><span class="cov0" title="0">{
                components = append(components, m.help())
        }</span>

        // Compose footer
        <span class="cov0" title="0">footer := m.helpWidget
        if m.err != nil </span><span class="cov0" title="0">{
                footer += styles.Regular.Padding(0, 1).
                        Background(styles.Red).
                        Foreground(styles.White).
                        Width(m.availableFooterMsgWidth()).
                        Render(m.err.Error())
        }</span> else<span class="cov0" title="0"> if m.info != "" </span><span class="cov0" title="0">{
                footer += styles.Padded.
                        Foreground(styles.Black).
                        Background(styles.LightGreen).
                        Width(m.availableFooterMsgWidth()).
                        Render(m.info)
        }</span> else<span class="cov0" title="0"> {
                footer += styles.Padded.
                        Foreground(styles.Black).
                        Background(styles.EvenLighterGrey).
                        Width(m.availableFooterMsgWidth()).
                        Render(m.info)
        }</span>
        <span class="cov0" title="0">footer += m.versionWidget

        // Add footer
        components = append(components, styles.Regular.
                Inline(true).
                MaxWidth(m.width).
                Width(m.width).
                Render(footer),
        )
        return strings.Join(components, "\n")</span>
}

var ()

func (m Model) availableFooterMsgWidth() int <span class="cov0" title="0">{
        return max(0, m.width-lipgloss.Width(m.helpWidget)-lipgloss.Width(m.versionWidget))
}</span>

func (m Model) viewHeight() int <span class="cov0" title="0">{
        vh := m.height - tui.FooterHeight
        if m.mode == promptMode </span><span class="cov0" title="0">{
                vh -= tui.PromptHeight
        }</span>
        <span class="cov0" title="0">if m.showHelp </span><span class="cov0" title="0">{
                vh -= tui.HelpWidgetHeight
        }</span>

        <span class="cov0" title="0">return vh</span>
}

// Width available within the main view
func (m Model) viewWidth() int <span class="cov0" title="0">{
        return max(tui.MinContentWidth, m.width)
}</span>

// help renders key bindings
func (m Model) help() string <span class="cov0" title="0">{
        // Compile list of bindings to render
        bindings := []key.Binding{tui.GlobalKeys.Help, tui.GlobalKeys.Quit}

        switch m.mode </span>{
        case promptMode:<span class="cov0" title="0">
                bindings = append(bindings, m.prompt.HelpBindings()...)</span>
        default:<span class="cov0" title="0">
                bindings = append(bindings, m.HelpBindings()...)</span>
        }

        <span class="cov0" title="0">bindings = append(bindings, keyMapToSlice(tui.GlobalKeys)...)
        bindings = removeDuplicateBindings(bindings)

        // Enumerate through each group of bindings, populating a series of
        // pairs of columns, one for keys, one for descriptions
        var (
                pairs []string
                width int
                rows  = tui.HelpWidgetHeight - 2 // -2 for border
        )
        for i := 0; i &lt; len(bindings); i += rows </span><span class="cov0" title="0">{
                var (
                        keys  []string
                        descs []string
                )
                for j := i; j &lt; min(i+rows, len(bindings)); j++ </span><span class="cov0" title="0">{
                        keys = append(keys, styles.HelpKeyStyle.Render(bindings[j].Help().Key))
                        descs = append(descs, styles.HelpDescStyle.Render(bindings[j].Help().Desc))
                }</span>

                // Render pair of columns; beyond the first pair, render a three space
                // left margin, in order to visually separate the pairs.
                <span class="cov0" title="0">var cols []string
                if len(pairs) &gt; 0 </span><span class="cov0" title="0">{
                        cols = []string{"   "}
                }</span>
                <span class="cov0" title="0">cols = append(cols,
                        strings.Join(keys, "\n"),
                        strings.Join(descs, "\n"),
                )

                pair := lipgloss.JoinHorizontal(lipgloss.Top, cols...)
                // check whether it exceeds the maximum width avail (the width of the
                // terminal, subtracting 2 for the borders).
                width += lipgloss.Width(pair)
                if width &gt; m.width-2 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">pairs = append(pairs, pair)</span>
        }

        // Join pairs of columns and enclose in a border
        <span class="cov0" title="0">content := lipgloss.JoinHorizontal(lipgloss.Top, pairs...)
        return styles.Border.Height(rows).Width(m.width - 2).Render(content)</span>
}

func removeDuplicateBindings(bindings []key.Binding) []key.Binding <span class="cov0" title="0">{
        seen := make(map[string]struct{})
        var i int
        for _, b := range bindings </span><span class="cov0" title="0">{
                key := strings.Join(b.Keys(), " ")
                if _, ok := seen[key]; ok </span><span class="cov0" title="0">{
                        // duplicate, skip
                        continue</span>
                }
                <span class="cov0" title="0">seen[key] = struct{}{}
                bindings[i] = b
                i++</span>
        }
        <span class="cov0" title="0">return bindings[:i]</span>
}

func keyMapToSlice(t any) (bindings []key.Binding) <span class="cov0" title="0">{
        typ := reflect.TypeOf(t)
        if typ.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                v := reflect.ValueOf(t).Field(i)
                bindings = append(bindings, v.Interface().(key.Binding))
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tui

import (
        tea "github.com/charmbracelet/bubbletea"
)

func CmdHandler(msg tea.Msg) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return msg
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package usecase

import (
        "fmt"
        "gophkeeper/internal/keeper/crypto"
        "gophkeeper/internal/keeper/storage"
)

type CreateLocalStoreUseCase struct {
}

func NewCreateStorageUsecase() *CreateLocalStoreUseCase <span class="cov0" title="0">{
        return &amp;CreateLocalStoreUseCase{}
}</span>

func (uc CreateLocalStoreUseCase) Call(path string, password string, encrypter crypto.Encrypter) (*storage.FileStorage, error) <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no path provided")
        }</span>

        <span class="cov0" title="0">fs, err := storage.NewFileStorage(path, password, encrypter)
        return fs, err</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package utils

import (
        "go.uber.org/dig"
        "go.uber.org/zap"
)

type LoggerDependencies struct {
        dig.In

        Level ZapLogLevel
}

func NewZapLogger(deps LoggerDependencies) (*zap.SugaredLogger, error) <span class="cov10" title="2">{
        lvl, err := zap.ParseAtomicLevel(string(deps.Level))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // cfg := zap.NewDevelopmentConfig()
        <span class="cov1" title="1">cfg := zap.Config{
                Encoding:         "console",                            // log format ("console" or "json")
                Level:            zap.NewAtomicLevelAt(zap.DebugLevel), // log level
                OutputPaths:      []string{"debug.log"},                // log path
                ErrorOutputPaths: []string{"stderr"},
                EncoderConfig:    zap.NewDevelopmentEncoderConfig(),
        }

        cfg.Level = lvl
        cfg.EncoderConfig.CallerKey = ""

        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return logger.Sugar(), nil</span>
}

type ZapLogLevel string
</pre>
		
		<pre class="file" id="file42" style="display: none">package utils

import "crypto/rand"

// Returns slice of random bytes of given size
func GenerateRandom(size int) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, size)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Provides auth functions, jwt vaildation and checks
package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "golang.org/x/crypto/bcrypt"
)

// Hash password using bcrypt
func HashPassword(password string) (string, error) <span class="cov10" title="4">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="3">return string(hash), nil</span>
}

// Check if provided password matches user's password
func CheckPassword(passwordHash, password string) bool <span class="cov5" title="2">{
        err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password))
        return err == nil
}</span>

// Creates JWT token
func CreateToken(userID int, expireDate time.Time, secretKey []byte) (string, error) <span class="cov5" title="2">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id": userID,
                "iss":     "gophkeeper",
                "exp":     expireDate.Unix(),
                "iat":     time.Now().Unix(),
        })

        tokenString, err := token.SignedString(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov5" title="2">return tokenString, nil</span>
}

// Verifies validity of token and returns claims
func VerifyToken(tokenText string, secretKey []byte) (jwt.MapClaims, error) <span class="cov5" title="2">{
        token, err := ParseToken(tokenText, secretKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">claims, err := GetClaims(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if IsExpired(claims) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is expired")
        }</span>

        <span class="cov1" title="1">return claims, nil</span>
}

// Parses token and returns pointer to jwt.Token
func ParseToken(tokenText string, secretKey []byte) (*jwt.Token, error) <span class="cov8" title="3">{
        token, err := jwt.Parse(tokenText, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="2">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov1" title="1">return secretKey, nil</span>
        })

        <span class="cov8" title="3">if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov1" title="1">return token, nil</span>
}

// Checks if provided token is expired
func IsExpired(claims jwt.MapClaims) bool <span class="cov1" title="1">{
        return float64(time.Now().Unix()) &gt; claims["exp"].(float64)
}</span>

// Extracts claims from provided token
func GetClaims(token *jwt.Token) (jwt.MapClaims, error) <span class="cov1" title="1">{
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract claims from token")
        }</span>

        <span class="cov1" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Server config
package config

import (
        "fmt"
        "gophkeeper/internal/server/entities"
        "strings"

        "github.com/spf13/viper"
        "go.uber.org/dig"
)

// Config is main configuration of client application.
type Config struct {
        Address     string
        PostgresDSN entities.SecretConnURI
        LogLevel    string
        SecretKey   string // key to sign jwt
        EnableTLS   bool
}

// Shortcut to use with dig
type Dependency struct {
        dig.In
        Config *Config
}

// Create server config from ENV vars and cmd flags
func New() *Config <span class="cov0" title="0">{
        viper.SetDefault("address", "127.0.0.1:50051")

        viper.SetDefault("verbose", false)
        viper.SetDefault("log-level", "INFO")
        viper.SetDefault("secret-key", "123456") // TODO: remove default, add warning

        viper.SetEnvPrefix("GOPH")
        viper.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
        viper.AutomaticEnv()

        cfg := &amp;Config{
                Address:     viper.GetString("address"),
                PostgresDSN: entities.SecretConnURI(viper.GetString("postgres-dsn")),
                LogLevel:    viper.GetString("log-level"),
                EnableTLS:   true,
        }

        return cfg
}</span>

func (c *Config) String() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("Configuration:\n")
        sb.WriteString(fmt.Sprintf("\t\tServer address: %s\n", c.Address))
        sb.WriteString(fmt.Sprintf("\t\tPostgres DSN: %s\n", c.Address))

        return sb.String()
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package entities

import (
        "fmt"
        "strconv"
        "strings"
)

// https://github.com/spf13/pflag/blob/master/README.md#usage
// must comply with https://pkg.go.dev/github.com/spf13/pflag@v1.0.5#Value.
type Address string

// Stringer.
func (a Address) String() string <span class="cov5" title="3">{
        return string(a)
}</span>

// Set value.
func (a *Address) Set(src string) error <span class="cov10" title="9">{
        chunks := strings.Split(src, ":")
        if len(chunks) != 2 </span><span class="cov7" title="5">{
                return fmt.Errorf("set address failed: %w", ErrBadAddressFormat)
        }</span>

        <span class="cov6" title="4">port := chunks[1]

        if _, err := strconv.Atoi(port); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("set address failed: %w", err)
        }</span>

        <span class="cov5" title="3">*a = Address(src)

        return nil</span>
}

// Return string for correct type conversion.
func (a Address) Type() string <span class="cov1" title="1">{
        return "string"
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package entities

import (
        "errors"
        "fmt"
)

var (
        ErrBadCredentials = errors.New("bad auth credentials")

        ErrStorageUnpingable = errors.New("healthcheck is not supported")
        ErrUnexpected        = errors.New("unexpected error")
        ErrBadAddressFormat  = errors.New("bad net address format")

        ErrSecretNotFound = errors.New("secret not found")
        ErrNoSecrets      = errors.New("no secrets found")

        ErrUserNotFound      = errors.New("user not found")
        ErrUserAlreadyExists = errors.New("user already exists")
)

func ErrorUserAlreadyExists(login string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w (%s)", ErrUserAlreadyExists, login)
}</span>

func ErrorSecretNotFound(secretID uint64) error <span class="cov0" title="0">{
        return fmt.Errorf("%w (id=%d)", ErrSecretNotFound, secretID)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package entities

import (
        "fmt"
        "os"
)

// FilePath is a path to a file on local filesystem.
type FilePath string

// Set validates that path exists and assigns it to FilePath.
// Required by pflags interface.
func (p *FilePath) Set(src string) error <span class="cov10" title="2">{
        if _, err := os.Stat(src); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid file path: %w", err)
        }</span>

        <span class="cov1" title="1">*p = FilePath(src)

        return nil</span>
}

// Returns string representation of stored path.
// Required by pflags interface.
func (p FilePath) String() string <span class="cov10" title="2">{
        return string(p)
}</span>

// Required by pflags interface.
func (p FilePath) Type() string <span class="cov1" title="1">{
        return "string"
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package entities

import (
        "regexp"
        "strings"
)

// Entity to hide sensitive strings which shouldn't leak to logs.
type SecretString string

// Stringer.
func (s SecretString) String() string <span class="cov10" title="5">{
        if len(s) &lt;= 2 </span><span class="cov7" title="3">{
                return string(s)
        }</span>

        <span class="cov4" title="2">masked := strings.Repeat("*", len(s)-2)
        return string(s[0]) + masked + string(s[len(s)-1])</span>
}

// Entity to hide sensitive URI values (e.g. login:password) which shouldn't leak to logs.
type SecretConnURI string

var _URISecrets = regexp.MustCompile(`(://).*:.*(@)`)

func (u SecretConnURI) String() string <span class="cov0" title="0">{
        return string(_URISecrets.ReplaceAll([]byte(u), []byte("$1*****:*****$2")))
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package grpcbackend

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "gophkeeper/cert"
        "gophkeeper/internal/server/config"
        grpchandlers "gophkeeper/internal/server/grpcbackend/handlers"
        "gophkeeper/internal/server/grpcbackend/interceptor"
        "gophkeeper/pkg/proto/keeper/grpcapi"

        "go.uber.org/dig"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        _ "google.golang.org/grpc/encoding/gzip"
)

type Backend struct {
        server *grpc.Server
}

type BackendDependencies struct {
        dig.In

        Logger        *zap.SugaredLogger
        Config        *config.Config
        HealthServer  *grpchandlers.HealthServer
        UsersServer   *grpchandlers.UsersServer
        SecretsServer *grpchandlers.SecretsServer
        // TODO:  NotificationServer    Notificationerver
}

// Backend constructor
func NewBackend(deps BackendDependencies) (*Backend, error) <span class="cov0" title="0">{
        iceps := make([]grpc.UnaryServerInterceptor, 0, 2)
        iceps = append(iceps, interceptor.Authentication([]byte(deps.Config.SecretKey)))
        iceps = append(iceps, interceptor.Logger(deps.Logger))

        grpcOpts := []grpc.ServerOption{
                grpc.ChainUnaryInterceptor(iceps...),
        }

        // TLS config
        if deps.Config.EnableTLS </span><span class="cov0" title="0">{
                tlsCreds, err := loadTLSConfig("ca-cert.pem", "server-cert.pem", "server-key.pem")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load TLS config: %w", err)
                }</span>

                // Append TLS credentials to server options
                <span class="cov0" title="0">grpcOpts = append(grpcOpts, grpc.Creds(tlsCreds))</span>
        }

        <span class="cov0" title="0">grpcServer := grpc.NewServer(grpcOpts...)

        // Register servers
        grpcapi.RegisterHealthServer(grpcServer, deps.HealthServer)
        grpcapi.RegisterUsersServer(grpcServer, deps.UsersServer)
        grpcapi.RegisterSecretsServer(grpcServer, deps.SecretsServer)

        backend := &amp;Backend{server: grpcServer}

        return backend, nil</span>
}

func loadTLSConfig(caCertFile, serverCertFile, serverKeyFile string) (credentials.TransportCredentials, error) <span class="cov0" title="0">{
        // Read CA cert
        caPem, err := cert.Cert.ReadFile(caCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CA cert: %w", err)
        }</span>

        // Read server cert
        <span class="cov0" title="0">serverCertPEM, err := cert.Cert.ReadFile(serverCertFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read server cert: %w", err)
        }</span>

        // Read server key
        <span class="cov0" title="0">serverKeyPEM, err := cert.Cert.ReadFile(serverKeyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read server key: %w", err)
        }</span>

        // Create key pair
        <span class="cov0" title="0">serverCert, err := tls.X509KeyPair(serverCertPEM, serverKeyPEM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load x509 key pair: %w", err)
        }</span>

        // Create cert pool and append CA's cert
        <span class="cov0" title="0">certPool := x509.NewCertPool()
        if !certPool.AppendCertsFromPEM(caPem) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to append CA cert to cert pool: %w", err)
        }</span>

        // Create config
        <span class="cov0" title="0">config := &amp;tls.Config{
                Certificates: []tls.Certificate{serverCert},
                ClientAuth:   tls.RequireAndVerifyClientCert,
                ClientCAs:    certPool,
        }

        return credentials.NewTLS(config), nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package grpcbackend

import (
        "gophkeeper/internal/server/config"
        "gophkeeper/internal/server/entities"
)

type GRPCServerAddress entities.Address

type GRPCServerAddressDependencies struct {
        config.Dependency
}

func NewGRPCServerAddress(deps GRPCServerAddressDependencies) GRPCServerAddress <span class="cov0" title="0">{
        return GRPCServerAddress(deps.Config.Address)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package grpchandlers

import (
        "context"
        "errors"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/service"
        "gophkeeper/pkg/proto/keeper/grpcapi"

        "go.uber.org/dig"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
)

// HealthServer verifies current health status of the service.
type HealthServer struct {
        grpcapi.UnimplementedHealthServer

        healthManager service.HealthManager
}

type HealthServerDependencies struct {
        dig.In

        HealthManager service.HealthManager
}

func NewHealthServer(deps HealthServerDependencies) *HealthServer <span class="cov10" title="3">{
        return &amp;HealthServer{
                healthManager: deps.HealthManager,
        }
}</span>

// Ping verifies connection to the database.
func (s HealthServer) Ping(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov10" title="3">{
        err := s.healthManager.Ping(ctx)
        if err == nil </span><span class="cov1" title="1">{
                return new(emptypb.Empty), nil
        }</span>

        <span class="cov6" title="2">if errors.Is(err, entities.ErrStorageUnpingable) </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unimplemented, err.Error())
        }</span>

        <span class="cov1" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package grpchandlers

import (
        "context"
        "errors"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/service"
        "gophkeeper/pkg/constants"
        "gophkeeper/pkg/convert"

        "go.uber.org/dig"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        pb "gophkeeper/pkg/proto/keeper/grpcapi"
)

type SecretsServer struct {
        pb.UnimplementedSecretsServer

        secretsManager service.SecretsManager
}

type SecretsServerDependencies struct {
        dig.In

        SecretsManager service.SecretsManager
}

func NewSecretsServer(deps SecretsServerDependencies) *SecretsServer <span class="cov9" title="6">{
        return &amp;SecretsServer{
                secretsManager: deps.SecretsManager,
        }
}</span>

// Saves new secret or updates existing one
func (s *SecretsServer) SaveUserSecretV1(ctx context.Context, in *pb.SaveUserSecretRequestV1) (*emptypb.Empty, error) <span class="cov4" title="2">{
        var err error

        userID, err := extractUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov4" title="2">secret := convert.ProtoToSecret(in.Secret)
        secret.UserID = int(userID)

        // Save secret
        if secret.ID &gt; 0 </span><span class="cov1" title="1">{
                _, err = s.secretsManager.UpdateSecret(ctx, secret)
        }</span> else<span class="cov1" title="1"> {
                _, err = s.secretsManager.CreateSecret(ctx, secret)
        }</span>
        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        // TODO: Send notifications

        <span class="cov4" title="2">return &amp;emptypb.Empty{}, nil</span>
}

func (s *SecretsServer) GetUserSecretV1(ctx context.Context, in *pb.GetUserSecretRequestV1) (*pb.GetUserSecretResponseV1, error) <span class="cov4" title="2">{
        var response pb.GetUserSecretResponseV1

        userID, err := extractUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        // Acquire secret
        <span class="cov4" title="2">secret, err := s.secretsManager.GetSecret(ctx, in.Id, userID)
        if errors.Is(err, entities.ErrSecretNotFound) </span><span class="cov1" title="1">{
                return nil, status.Error(codes.NotFound, err.Error())
        }</span>

        // Other errors
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov1" title="1">response.Secret = convert.SecretToProto(secret)

        return &amp;response, nil</span>
}

func (s *SecretsServer) GetUserSecretsV1(ctx context.Context, in *emptypb.Empty) (*pb.GetUserSecretsResponseV1, error) <span class="cov1" title="1">{
        var response pb.GetUserSecretsResponseV1

        userID, err := extractUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        // Acquire secrets
        <span class="cov1" title="1">secrets, err := s.secretsManager.GetUserSecrets(ctx, userID)

        // Other errors
        if err != nil &amp;&amp; !errors.Is(err, entities.ErrNoSecrets) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov1" title="1">response.Secrets = convert.SecretsToProto(secrets)

        return &amp;response, nil</span>
}

func (s *SecretsServer) DeleteUserSecretV1(ctx context.Context, in *pb.DeleteUserSecretRequestV1) (*emptypb.Empty, error) <span class="cov4" title="2">{

        userID, err := extractUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        // Delete
        <span class="cov4" title="2">err = s.secretsManager.DeleteSecret(ctx, in.Id, userID)
        if errors.Is(err, entities.ErrSecretNotFound) </span><span class="cov1" title="1">{
                return nil, status.Error(codes.NotFound, err.Error())
        }</span>

        // Other errors
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov1" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func extractUserID(ctx context.Context) (uint64, error) <span class="cov10" title="7">{
        uid := ctx.Value(constants.CtxUserIDKey)

        userID, ok := uid.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("failed to extract user id from context")
        }</span>

        <span class="cov10" title="7">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package grpchandlers

import (
        "context"
        "errors"
        "gophkeeper/internal/server/auth"
        "gophkeeper/internal/server/config"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/service"
        "gophkeeper/pkg/constants"
        "strconv"
        "time"

        pb "gophkeeper/pkg/proto/keeper/grpcapi"

        "go.uber.org/dig"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

const tokenLifetime = time.Hour * 24

type UsersServer struct {
        pb.UnimplementedUsersServer

        config       *config.Config
        usersManager service.UsersManager
}

type UsersServerDependencies struct {
        dig.In

        Config       *config.Config
        UsersManager service.UsersManager
}

func NewUsersServer(deps UsersServerDependencies) *UsersServer <span class="cov10" title="4">{
        return &amp;UsersServer{
                config:       deps.Config,
                usersManager: deps.UsersManager,
        }
}</span>

func (s *UsersServer) RegisterV1(ctx context.Context, in *pb.RegisterRequestV1) (*pb.RegisterResponseV1, error) <span class="cov5" title="2">{
        var response pb.RegisterResponseV1

        // Register user
        user, err := s.usersManager.RegisterUser(ctx, in.Login, in.Password)

        // Check if user exists
        if errors.Is(err, entities.ErrUserAlreadyExists) </span><span class="cov1" title="1">{
                return nil, status.Error(codes.AlreadyExists, err.Error())
        }</span>

        // Other errors
        <span class="cov1" title="1">if err != nil &amp;&amp; !errors.Is(err, entities.ErrUserNotFound) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        // Generate access token
        <span class="cov1" title="1">token, err := s.authUser(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to auth: %v", err)
        }</span>

        <span class="cov1" title="1">response.AccessToken = token

        return &amp;response, nil</span>
}

func (s *UsersServer) LoginV1(ctx context.Context, in *pb.LoginRequestV1) (*pb.LoginResponseV1, error) <span class="cov5" title="2">{
        var response pb.LoginResponseV1

        // Login user
        user, err := s.usersManager.LoginUser(ctx, in.Login, in.Password)

        // Check credentials
        if errors.Is(err, entities.ErrBadCredentials) </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>

        // Other errors
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>

        // Generate access token
        <span class="cov1" title="1">token, err := s.authUser(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to auth: %v", err)
        }</span>

        <span class="cov1" title="1">response.AccessToken = token

        return &amp;response, nil</span>
}

func (s *UsersServer) authUser(userID int) (string, error) <span class="cov5" title="2">{
        token, err := auth.CreateToken(userID, time.Now().Add(tokenLifetime), []byte(s.config.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov5" title="2">return token, nil</span>
}

func extractClientID(ctx context.Context) (int32, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("failed to get metadata")
        }</span>

        <span class="cov0" title="0">values := md.Get(constants.ClientIDHeader)
        if len(values) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("missing client id metadata")
        }</span>

        <span class="cov0" title="0">v := values[0]

        id, err := strconv.Atoi(v)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int32(id), nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package interceptor

import (
        "context"
        "gophkeeper/internal/server/auth"
        "gophkeeper/pkg/constants"
        "strings"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Checks auth token passed from context, returns new context with user id embedded
func authContext(secretKey []byte, ctx context.Context) (context.Context, error) <span class="cov10" title="4">{
        // Get token from metadata
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "unable to extract metadata")
        }</span>

        <span class="cov8" title="3">values := md.Get(constants.AccessTokenHeader)

        if len(values) == 0 </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "missing access token")
        }</span>

        <span class="cov5" title="2">tokenText := values[0]

        // Parse and verify JWT token
        tokenMap, err := auth.VerifyToken(tokenText, secretKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Unauthenticated, "failed to verify token: %s", err.Error())
        }</span>

        // Extract user from claims
        <span class="cov1" title="1">uid, ok := tokenMap["user_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "no user id in claims")
        }</span>

        // Cast to float from claims
        <span class="cov1" title="1">userID, ok := uid.(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "invalid user id in claims")
        }</span>

        // Store user ID in context
        <span class="cov1" title="1">ctx = context.WithValue(ctx, constants.CtxUserIDKey, uint64(userID))

        return ctx, nil</span>
}

// Unary auth interceptor checks provided in metadata token
func Authentication(secretKey []byte) grpc.UnaryServerInterceptor <span class="cov1" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="3">{

                // Allow login and register methods
                if strings.Contains(info.FullMethod, "RegisterV1") || strings.Contains(info.FullMethod, "LoginV1") </span><span class="cov1" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov5" title="2">var err error

                ctx, err = authContext(secretKey, ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package interceptor

import (
        "context"
        "gophkeeper/internal/server/utils"

        "google.golang.org/grpc/metadata"
)

func extractMetaData(ctx context.Context) (string, string) <span class="cov10" title="2">{
        var requestID, clientIP string

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov10" title="2">{
                return requestID, clientIP
        }</span>

        <span class="cov0" title="0">if values := md.Get("X-Request-ID"); len(values) &gt; 0 </span><span class="cov0" title="0">{
                requestID = values[0]
        }</span> else<span class="cov0" title="0"> {
                requestID = utils.GenerateRequestID()
        }</span>

        <span class="cov0" title="0">if values := md.Get("X-Real-IP"); len(values) &gt; 0 </span><span class="cov0" title="0">{
                clientIP = values[0]
        }</span>

        <span class="cov0" title="0">return requestID, clientIP</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package interceptor

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
)

// Logs gRPC requests for unary server requests
func Logger(logger *zap.SugaredLogger) grpc.UnaryServerInterceptor <span class="cov1" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov10" title="2">{
                t := time.Now()

                // Handle request
                res, err := handler(ctx, req)

                // Get headers
                requestID, clientIP := extractMetaData(ctx)

                // Count request duration in ms
                latency := time.Since(t)
                miliSeconds := fmt.Sprintf("%d ms", latency.Milliseconds())

                // Log body
                logParams := []interface{}{
                        "rid", requestID,
                        "method", info.FullMethod,
                        "duration", miliSeconds,
                        "remote_addr", clientIP,
                }

                // Log error or just log general info
                if err != nil </span><span class="cov1" title="1">{
                        logParams = append(logParams, "error", err)
                        logger.Errorln(logParams...)
                }</span> else<span class="cov1" title="1"> {
                        logger.Infoln(logParams...)
                }</span>

                <span class="cov10" title="2">return res, err</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package grpcbackend

import (
        "context"
        "fmt"
        "net"

        "go.uber.org/dig"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

// HTTP-server wrapper
type GRPCServer struct {
        address GRPCServerAddress
        server  *grpc.Server
        log     *zap.SugaredLogger
        notify  chan error
}

type GRPCServerDependencies struct {
        dig.In

        Address GRPCServerAddress
        Backend *Backend
        Logger  *zap.SugaredLogger
}

// Constructor
func NewGRPCServer(deps GRPCServerDependencies) *GRPCServer <span class="cov0" title="0">{
        return &amp;GRPCServer{
                address: deps.Address,
                server:  deps.Backend.server,
                log:     deps.Logger,
                notify:  make(chan error, 1),
        }
}</span>

// Run server in a goroutine
func (s *GRPCServer) Start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                s.log.Infof("starting GRPC-server on %s", s.address)

                listen, err := net.Listen("tcp", string(s.address))
                if err != nil </span><span class="cov0" title="0">{
                        s.notify &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">s.notify &lt;- s.server.Serve(listen)
                close(s.notify)</span>
        }()
}

func (s *GRPCServer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if s.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.server.GracefulStop()
        return nil</span>
}

// Return channel to handle errors
func (s *GRPCServer) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

// Describe itself
func (s GRPCServer) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("GRPCserver [addr=%s]", s.address)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/repository"
        strg "gophkeeper/internal/server/storage/postgres"
        "gophkeeper/pkg/models"

        "github.com/jmoiron/sqlx"
        "go.uber.org/dig"
)

var _ repository.SecretsRepository = SecretsRepository{}

type SecretsRepositoryDependencies struct {
        dig.In
        PostgresConn *strg.PostgresConn
}

// Secrets repository using PostgreSQL
type SecretsRepository struct {
        db *sqlx.DB
}

// Create new postgresql secret repository
func NewSecretsRepository(deps SecretsRepositoryDependencies) *SecretsRepository <span class="cov10" title="4">{
        return &amp;SecretsRepository{
                db: deps.PostgresConn.DB,
        }
}</span>

// Find secret by id
func (r SecretsRepository) GetSecret(ctx context.Context, secretID uint64, userID uint64) (*models.Secret, error) <span class="cov5" title="2">{
        var secret models.Secret

        query := `SELECT * FROM secrets WHERE id = $1 AND user_id = $2`

        err := r.db.QueryRowxContext(ctx, query, secretID, userID).StructScan(&amp;secret)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                return nil, entities.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return &amp;secret, err</span>
}

// Find user's secrets
func (r SecretsRepository) GetUserSecrets(ctx context.Context, userID uint64) (models.Secrets, error) <span class="cov0" title="0">{
        var secrets models.Secrets

        query := "SELECT * FROM secrets WHERE user_id = $1 ORDER BY updated_at DESC"
        err := r.db.SelectContext(ctx, &amp;secrets, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return secrets, nil</span>
}

// Create new secret
func (r SecretsRepository) Create(ctx context.Context, secret *models.Secret) (uint64, error) <span class="cov1" title="1">{
        var newSecretID uint64

        query := `INSERT INTO secrets (user_id, title, metadata, secret_type, payload)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id`

        result := r.db.QueryRowxContext(ctx, query, secret.UserID, secret.Title, secret.Metadata, secret.SecretType, secret.Payload)
        err := result.Scan(&amp;newSecretID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return newSecretID, nil</span>
}

// Ensure secret exists and update secret (in one transaction)
func (r SecretsRepository) Update(ctx context.Context, secret *models.Secret) error <span class="cov1" title="1">{
        return runInTx(r.db, func(tx *sqlx.Tx) error </span><span class="cov1" title="1">{
                err := tx.QueryRowxContext(ctx, "SELECT 1 FROM secrets WHERE id = $1 FOR UPDATE", secret.ID).Scan(new(int))
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("secret with ID %d not found: %w", secret.ID, err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov1" title="1">sql := `UPDATE secrets SET updated_at = $1, title = $2, metadata = $3, secret_type = $4, payload = $5 WHERE id = $6;`
                _, err = tx.ExecContext(ctx, sql,
                        secret.UpdatedAt,
                        secret.Title,
                        secret.Metadata,
                        secret.SecretType,
                        secret.Payload,
                        secret.ID,
                )

                return err</span>
        })
}

func (r SecretsRepository) Delete(ctx context.Context, secretID uint64, userID uint64) error <span class="cov1" title="1">{
        query := `DELETE FROM secrets WHERE id = $1 AND user_id = $2`
        _, err := r.db.ExecContext(ctx, query, secretID, userID)

        return err
}</span>

func (r SecretsRepository) Pong() <span class="cov0" title="0">{
        fmt.Println("alive")
}</span>

func runInTx(db *sqlx.DB, fn func(tx *sqlx.Tx) error) error <span class="cov1" title="1">{
        tx, err := db.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = fn(tx)
        if err == nil </span><span class="cov1" title="1">{
                return tx.Commit()
        }</span>

        <span class="cov0" title="0">rollbackErr := tx.Rollback()
        if rollbackErr != nil </span><span class="cov0" title="0">{
                return errors.Join(err, rollbackErr)
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"

        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/repository"
        strg "gophkeeper/internal/server/storage/postgres"
        "gophkeeper/pkg/models"

        "github.com/jmoiron/sqlx"
        "go.uber.org/dig"
)

var _ repository.UsersRepository = UsersRepository{}

// User repository using PostgreSQL
type UsersRepository struct {
        db *sqlx.DB
}

type UsersRepositoryDependencies struct {
        dig.In
        PostgresConn *strg.PostgresConn
}

// Create new postgresql user repository
func NewUsersRepository(deps UsersRepositoryDependencies) *UsersRepository <span class="cov10" title="3">{
        return &amp;UsersRepository{
                db: deps.PostgresConn.DB,
        }
}</span>

// Create new User
func (r UsersRepository) Create(ctx context.Context, user models.User) (int, error) <span class="cov1" title="1">{
        var newUserID int

        result := r.db.QueryRowContext(ctx,
                "INSERT INTO users (login, password) VALUES ($1, $2) RETURNING id",
                user.Login,
                user.Password,
        )

        err := result.Scan(&amp;newUserID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return newUserID, nil</span>
}

// Get User by ID
func (r UsersRepository) GetUserByID(ctx context.Context, ID int) (*models.User, error) <span class="cov6" title="2">{
        var user models.User

        err := r.db.QueryRowxContext(ctx, "SELECT id, login, created_at, password FROM users WHERE id = $1", ID).StructScan(&amp;user)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                return nil, entities.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return &amp;user, err</span>
}

// Get User by login
func (r UsersRepository) GetUserByLogin(ctx context.Context, login string) (*models.User, error) <span class="cov6" title="2">{
        var user models.User

        err := r.db.QueryRowxContext(ctx, "SELECT id, login, created_at, password FROM users WHERE login = $1", login).StructScan(&amp;user)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                return nil, entities.ErrUserNotFound
        }</span>

        <span class="cov1" title="1">return &amp;user, err</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package server

import (
        "context"
        "fmt"

        "gophkeeper/internal/server/config"
        "gophkeeper/internal/server/grpcbackend"

        "gophkeeper/internal/server/storage"

        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "go.uber.org/dig"
        "go.uber.org/zap"
)

const shutdownTimeout = 60 * time.Second

// Main server app
type Server struct {
        config  *config.Config
        log     *zap.SugaredLogger
        deps    *dig.Container
        storage storage.ServerStorage

        grpcServer *grpcbackend.GRPCServer
}

type ServerDependencies struct {
        dig.In

        Config     *config.Config
        Storage    storage.ServerStorage
        GRPCServer *grpcbackend.GRPCServer
        Logger     *zap.SugaredLogger
}

// Create new Server
func New(deps ServerDependencies) *Server <span class="cov0" title="0">{
        server := &amp;Server{
                config:  deps.Config,
                log:     deps.Logger,
                storage: deps.Storage,

                grpcServer: deps.GRPCServer,
        }

        return server
}</span>

// Start all subservices
func (s *Server) Start() error <span class="cov0" title="0">{
        s.grpcServer.Start()

        // Graceful shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        s.log.Info("server ready")

        select </span>{
        case sig := &lt;-quit:<span class="cov0" title="0">
                s.log.Info("interrupt: signal " + sig.String())</span>
        case err := &lt;-s.grpcServer.Notify():<span class="cov0" title="0">
                s.log.Error(err, "Server -&gt; Start() -&gt; s.grpcServer.Notify")</span>
        }

        <span class="cov0" title="0">s.shutdown()

        return nil</span>
}

// Stringer for logging
func (s *Server) String() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("Configuration:\n")
        sb.WriteString(fmt.Sprintf("\t\tListen: %s\n", s.config.Address))

        sb.WriteString("Storage:\n")
        sb.WriteString(s.storage.String())

        return sb.String()
}</span>

// Shutdown server and it subservices. Will block upto shutdownTimeout
func (s *Server) shutdown() <span class="cov0" title="0">{
        s.log.Info("shutting down application now")

        stopped := make(chan struct{})
        stopCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                s.log.Info("shutting down GRPC API...")
                if err := s.grpcServer.Shutdown(stopCtx); err != nil </span><span class="cov0" title="0">{
                        s.log.Error(err)
                }</span>

                <span class="cov0" title="0">close(stopped)</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-stopped:<span class="cov0" title="0">
                s.log.Info("server shutdown successful")</span>

        case &lt;-stopCtx.Done():<span class="cov0" title="0">
                s.log.Info("shutdown timeout exceeded")</span>
        }
}

// Common interface for different subservices: http, grpc, profiling, etc
type ServerService interface {
        Start()
        Notify() &lt;-chan error
        Shutdown(ctx context.Context) error
        String() string
}

var _ ServerService = (*grpcbackend.GRPCServer)(nil)
</pre>
		
		<pre class="file" id="file61" style="display: none">package service

import (
        "context"
        "fmt"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/storage"
        "time"

        "go.uber.org/dig"
)

const defaultTimeout = 5 * time.Second

var _ HealthManager = HealthService{}

type HealthManager interface {
        Ping(ctx context.Context) error
}

type HealthManagerDependencies struct {
        dig.In
        Storage storage.ServerStorage
}

type HealthService struct {
        storage storage.ServerStorage
}

// Service constructor
func NewHealthService(deps HealthManagerDependencies) *HealthService <span class="cov10" title="3">{
        return &amp;HealthService{storage: deps.Storage}
}</span>

// Interface to check if storage supports healthcheck
type PingableStorage interface {
        Ping(ctx context.Context) error
}

// Ping-pong
func (s HealthService) Ping(ctx context.Context) error <span class="cov10" title="3">{
        ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
        defer cancel()

        strg, ok := s.storage.(PingableStorage)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("storage ping failed: %w", entities.ErrStorageUnpingable)
        }</span>

        <span class="cov10" title="3">if err := strg.Ping(ctx); err != nil </span><span class="cov6" title="2">{
                return fmt.Errorf("storage check failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package service

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/repository"

        "gophkeeper/pkg/models"

        "go.uber.org/dig"
)

//go:generate mockgen -source secret.go -destination mocks/mock_secret.go -package service

var _ SecretsManager = SecretsService{}

// Interface for secrets service
type SecretsManager interface {
        GetSecret(ctx context.Context, ID uint64, userID uint64) (*models.Secret, error)
        GetUserSecrets(ctx context.Context, userID uint64) (models.Secrets, error)
        CreateSecret(ctx context.Context, secret *models.Secret) (*models.Secret, error)
        UpdateSecret(ctx context.Context, secret *models.Secret) (*models.Secret, error)
        DeleteSecret(ctx context.Context, ID uint64, userID uint64) error
}

type SecretsManagerDependencies struct {
        dig.In
        Repo repository.SecretsRepository
}

// Secrets service implementation
type SecretsService struct {
        repo repository.SecretsRepository
}

// Create new secret service
func NewSecretsService(deps SecretsManagerDependencies) *SecretsService <span class="cov10" title="3">{
        return &amp;SecretsService{repo: deps.Repo}
}</span>

// Returns decrypted secret
func (s SecretsService) GetSecret(ctx context.Context, secretID uint64, userID uint64) (*models.Secret, error) <span class="cov6" title="2">{
        secret, err := s.repo.GetSecret(ctx, secretID, userID)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                return nil, entities.ErrorSecretNotFound(secretID)
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return secret, nil</span>
}

// Get user's secrets list
func (s SecretsService) GetUserSecrets(ctx context.Context, userID uint64) (models.Secrets, error) <span class="cov0" title="0">{
        secrets, err := s.repo.GetUserSecrets(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(secrets) == 0 </span><span class="cov0" title="0">{
                return nil, entities.ErrNoSecrets
        }</span>

        <span class="cov0" title="0">return secrets, nil</span>
}

// Try create secret
func (s SecretsService) CreateSecret(ctx context.Context, secret *models.Secret) (*models.Secret, error) <span class="cov6" title="2">{
        var err error

        secret.ID, err = s.repo.Create(ctx, secret)

        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create secret: %w", err)
        }</span>

        <span class="cov1" title="1">return secret, nil</span>
}

// Try update secret
func (s SecretsService) UpdateSecret(ctx context.Context, secret *models.Secret) (*models.Secret, error) <span class="cov0" title="0">{
        err := s.repo.Update(ctx, secret)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return nil, entities.ErrorSecretNotFound(secret.ID)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store secret: %w", err)
        }</span>

        <span class="cov0" title="0">return secret, nil</span>
}

// Delete secret
func (s SecretsService) DeleteSecret(ctx context.Context, secretID uint64, userID uint64) error <span class="cov1" title="1">{
        err := s.repo.Delete(ctx, secretID, userID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package service

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "gophkeeper/internal/server/entities"
        "gophkeeper/internal/server/repository"
        "gophkeeper/internal/server/utils"
        "gophkeeper/pkg/models"

        "go.uber.org/dig"
)

//go:generate mockgen -source user.go -destination mocks/mock_user.go -package service

var _ UsersManager = UsersService{}

// User service interface
type UsersManager interface {
        RegisterUser(ctx context.Context, login string, password string) (*models.User, error)
        LoginUser(ctx context.Context, login string, password string) (*models.User, error)
}

type UsersManagerDependencies struct {
        dig.In
        Repo repository.UsersRepository
}

// User service implementation
type UsersService struct {
        repo repository.UsersRepository
}

// Create new UserService
func NewUsersService(deps UsersManagerDependencies) *UsersService <span class="cov10" title="7">{
        return &amp;UsersService{repo: deps.Repo}
}</span>

// Register new User
func (s UsersService) RegisterUser(ctx context.Context, login string, password string) (*models.User, error) <span class="cov6" title="3">{
        var newUser models.User

        // ensure we have no same login
        user, err := s.repo.GetUserByLogin(ctx, login)

        if err != nil &amp;&amp; !errors.Is(err, entities.ErrUserNotFound) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch user: %w", err)
        }</span>
        <span class="cov6" title="3">if user != nil </span><span class="cov1" title="1">{
                return nil, entities.ErrorUserAlreadyExists(login)
        }</span>

        <span class="cov4" title="2">hashedPassword, err := utils.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate password hash: %w", err)
        }</span>

        // create new user
        <span class="cov4" title="2">newUser = models.User{Login: login, Password: hashedPassword}

        var newUserID int
        newUserID, err = s.repo.Create(ctx, newUser)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov1" title="1">newUser.ID = newUserID

        return &amp;newUser, nil</span>
}

// Login user
func (s UsersService) LoginUser(ctx context.Context, login string, password string) (*models.User, error) <span class="cov7" title="4">{
        user, err := s.repo.GetUserByLogin(ctx, login)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                return user, entities.ErrBadCredentials
        }</span>

        <span class="cov6" title="3">if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to authenticate user: %w", err)
        }</span>

        <span class="cov4" title="2">if !utils.ComparePassword(user.Password, password) </span><span class="cov1" title="1">{
                return nil, entities.ErrBadCredentials
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package postgres

import (
        "gophkeeper/internal/server/config"
        "gophkeeper/internal/server/entities"

        "github.com/jmoiron/sqlx"
        "go.uber.org/dig"
)

/* PostgresDSN */
type PostgresDSN entities.SecretConnURI

type PostgresDSNDependencies struct {
        config.Dependency
}

func NewPostgresDSN(deps PostgresDSNDependencies) PostgresDSN <span class="cov0" title="0">{
        return PostgresDSN(deps.Config.PostgresDSN)
}</span>

/* PostgresConn */
type PostgresConn struct {
        DB  *sqlx.DB
        Err error
        DSN PostgresDSN
}

type PostgresConnDependencies struct {
        dig.In
        DSN PostgresDSN
}

func NewPostgresConn(deps PostgresConnDependencies) *PostgresConn <span class="cov0" title="0">{
        conn := &amp;PostgresConn{}
        conn.DB, conn.Err = sqlx.Open("pgx", string(deps.DSN))
        conn.DSN = deps.DSN

        if conn.Err != nil </span><span class="cov0" title="0">{
                return conn
        }</span>

        <span class="cov0" title="0">if err := conn.DB.Ping(); err != nil </span><span class="cov0" title="0">{
                conn.Err = err
        }</span>

        <span class="cov0" title="0">return conn</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package postgres

import (
        "context"
        "fmt"
        "gophkeeper/internal/server/storage"
        "gophkeeper/internal/server/storage/postgres/migrations"
        "strings"
        "time"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "github.com/pressly/goose/v3"
        "go.uber.org/dig"
)

const migrationTimeout = 5 * time.Second

var _ storage.ServerStorage = PostgresStorage{}

type PostgresStorageDependencies struct {
        dig.In
        PostgresConn *PostgresConn
}

type PostgresStorage struct {
        db  *sqlx.DB
        dsn PostgresDSN
}

// PostgresStorage constructor
func NewPostgresStorage(deps PostgresStorageDependencies) (*PostgresStorage, error) <span class="cov0" title="0">{
        conn := deps.PostgresConn
        if conn.Err != nil </span><span class="cov0" title="0">{
                return nil, conn.Err
        }</span>

        <span class="cov0" title="0">storage := &amp;PostgresStorage{db: conn.DB}

        // run migrations
        if err := storage.migrate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return storage, nil</span>
}

// Ping storage
func (s PostgresStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return s.db.Ping()
}</span>

// Close storage
func (s PostgresStorage) Close(ctx context.Context) error <span class="cov0" title="0">{
        return s.db.Close()
}</span>

// Stringer for logging
func (s PostgresStorage) String() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("\t\tDSN: %s\n", s.dsn))

        return sb.String()
}</span>

func (s PostgresStorage) GetDB() *sqlx.DB <span class="cov0" title="0">{
        fmt.Println("getDB")
        return s.db
}</span>

// Performs DB migrations
func (s PostgresStorage) migrate() error <span class="cov0" title="0">{
        goose.SetBaseFS(migrations.Migrations)

        ctx, cancel := context.WithTimeout(context.Background(), migrationTimeout)
        defer cancel()

        err := goose.RunContext(ctx, "up", s.db.DB, ".")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package utils

import (
        "go.uber.org/dig"
        "go.uber.org/zap"
)

type LoggerDependencies struct {
        dig.In

        Level ZapLogLevel
}

func NewZapLogger(deps LoggerDependencies) (*zap.SugaredLogger, error) <span class="cov10" title="2">{
        lvl, err := zap.ParseAtomicLevel(string(deps.Level))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">cfg := zap.NewDevelopmentConfig()
        cfg.Level = lvl
        cfg.EncoderConfig.CallerKey = ""

        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return logger.Sugar(), nil</span>
}

type ZapLogLevel string
</pre>
		
		<pre class="file" id="file67" style="display: none">package utils

func LuhnCheck(number string) bool <span class="cov6" title="11">{
        sum, length := 0, len(number)
        if length &lt; 2 </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov5" title="9">for index, num := range number </span><span class="cov10" title="68">{
                dig := int(num - '0')
                if length%2 == index%2 </span><span class="cov8" title="31">{
                        dig *= 2
                        if dig &gt; 9 </span><span class="cov6" title="14">{
                                dig = dig%10 + dig/10
                        }</span>
                }
                <span class="cov10" title="68">sum += dig</span>
        }
        <span class="cov5" title="9">return sum%10 == 0</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package utils

import (
        uuid "github.com/satori/go.uuid"
)

func GenerateRequestID() string <span class="cov8" title="1">{
        return uuid.NewV4().String()
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/base64"

        "golang.org/x/crypto/bcrypt"
)

func GenerateRandomString(length int) string <span class="cov1" title="1">{
        b := make([]byte, length)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">return base64.StdEncoding.EncodeToString(b)</span>
}

func HashPassword(password string) (string, error) <span class="cov10" title="2">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="2">return string(hashedPassword), nil</span>
}

func ComparePassword(hash, password string) bool <span class="cov10" title="2">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Provides functions for converting between protobuf models and regular models
package convert

import (
        "gophkeeper/pkg/models"

        "google.golang.org/protobuf/types/known/timestamppb"

        pb "gophkeeper/pkg/proto/keeper/grpcapi"
)

// Returns  secret type
func ProtoToType(pbType pb.SecretType) models.SecretType <span class="cov10" title="7">{
        switch pbType </span>{
        case pb.SecretType_SECRET_TYPE_CREDENTIAL:<span class="cov6" title="3">
                return models.CredSecret</span>
        case pb.SecretType_SECRET_TYPE_TEXT:<span class="cov1" title="1">
                return models.TextSecret</span>
        case pb.SecretType_SECRET_TYPE_BLOB:<span class="cov1" title="1">
                return models.BlobSecret</span>
        case pb.SecretType_SECRET_TYPE_CARD:<span class="cov1" title="1">
                return models.CardSecret</span>
        default:<span class="cov1" title="1">
                return models.UnknownSecret</span>
        }
}

// Returns protobuf secret type
func TypeToProto(sType string) pb.SecretType <span class="cov10" title="7">{
        switch sType </span>{
        case string(models.CredSecret):<span class="cov6" title="3">
                return pb.SecretType_SECRET_TYPE_CREDENTIAL</span>
        case string(models.TextSecret):<span class="cov1" title="1">
                return pb.SecretType_SECRET_TYPE_TEXT</span>
        case string(models.BlobSecret):<span class="cov1" title="1">
                return pb.SecretType_SECRET_TYPE_BLOB</span>
        case string(models.CardSecret):<span class="cov1" title="1">
                return pb.SecretType_SECRET_TYPE_CARD</span>
        default:<span class="cov1" title="1">
                return pb.SecretType_SECRET_TYPE_UNSPECIFIED</span>
        }
}

// Converts secret models to protobuf counterpart
func SecretToProto(secret *models.Secret) *pb.Secret <span class="cov4" title="2">{
        pbSecret := &amp;pb.Secret{
                Id:         secret.ID,
                Title:      secret.Title,
                Metadata:   secret.Metadata,
                Payload:    secret.Payload,
                SecretType: TypeToProto(secret.SecretType),
                CreatedAt:  timestamppb.New(secret.CreatedAt),
                UpdatedAt:  timestamppb.New(secret.UpdatedAt),
        }

        return pbSecret
}</span>

// Converts protobuf models to regular models
func ProtoToSecret(pbSecret *pb.Secret) *models.Secret <span class="cov4" title="2">{
        secret := &amp;models.Secret{
                ID:         pbSecret.Id,
                Title:      pbSecret.Title,
                Metadata:   pbSecret.Metadata,
                SecretType: string(ProtoToType(pbSecret.SecretType)),
                Payload:    pbSecret.Payload,
                CreatedAt:  pbSecret.CreatedAt.AsTime(),
                UpdatedAt:  pbSecret.UpdatedAt.AsTime(),
        }

        return secret
}</span>

// Converts protobuf models to regular models
func ProtoToSecrets(pbSecrets []*pb.Secret) []*models.Secret <span class="cov1" title="1">{
        secr := []*models.Secret{}

        for _, s := range pbSecrets </span><span class="cov1" title="1">{
                secr = append(secr, ProtoToSecret(s))
        }</span>

        <span class="cov1" title="1">return secr</span>
}

// Converts secret models to protobuf counterpart
func SecretsToProto(secrets []*models.Secret) []*pb.Secret <span class="cov1" title="1">{
        secr := []*pb.Secret{}

        for _, s := range secrets </span><span class="cov1" title="1">{
                secr = append(secr, SecretToProto(s))
        }</span>

        <span class="cov1" title="1">return secr</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Common models for server and client
package models

import (
        "bytes"
        "encoding/json"
        "fmt"
        "strconv"
        "time"
)

type Secret struct {
        ID         uint64    `db:"id" json:"id"`
        UserID     int       `db:"user_id"`
        Title      string    `db:"title" json:"title"`
        Metadata   string    `db:"metadata" json:"metadata"`
        SecretType string    `db:"secret_type" json:"secret_type"`
        Payload    []byte    `db:"payload" json:"payload"`
        CreatedAt  time.Time `db:"created_at" json:"created_at"`
        UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`

        Creds *Credentials `db:"-"`
        Text  *Text        `db:"-"`
        Blob  *Blob        `db:"-"`
        Card  *Card        `db:"-"`
}

type Secrets []*Secret

func NewSecret(t SecretType) *Secret <span class="cov0" title="0">{
        s := Secret{SecretType: string(t)}

        return &amp;s
}</span>

// Secret type
type SecretType string

const (
        CredSecret    SecretType = "credential"
        TextSecret    SecretType = "text"
        BlobSecret    SecretType = "blob"
        CardSecret    SecretType = "card"
        UnknownSecret SecretType = "unknown"
)

type Credentials struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

type Text struct {
        Content string `json:"content"`
}

type Blob struct {
        FileName  string `json:"file_name"`
        FileBytes []byte `json:"file_bytes"`
}

type Card struct {
        Number   string `json:"number"`
        ExpYear  uint32 `json:"exp_year"`
        ExpMonth uint32 `json:"exp_month"`
        CVV      uint32 `json:"cvv"`
}

func (s Secret) ToClipboard() string <span class="cov10" title="3">{
        var b bytes.Buffer

        switch SecretType(s.SecretType) </span>{
        case CredSecret:<span class="cov1" title="1">
                b.WriteString(fmt.Sprintf("login: %s\n", s.Creds.Login))
                b.WriteString(fmt.Sprintf("password: %s", s.Creds.Password))</span>
        case CardSecret:<span class="cov1" title="1">
                b.WriteString(fmt.Sprintf("Card Number: %s\n", s.Card.Number))
                b.WriteString(fmt.Sprintf("Exp: %d/%d", s.Card.ExpMonth, s.Card.ExpYear))
                b.WriteString(fmt.Sprintf("CVV: %d", s.Card.CVV))</span>
        case TextSecret:<span class="cov1" title="1">
                b.WriteString(fmt.Sprintf("Text: %s\n", s.Text.Content))</span>
        case BlobSecret:<span class="cov0" title="0"></span>
                // do nothing, file should be saved
        }

        <span class="cov10" title="3">return b.String()</span>
}

const timeFormat = "2006-01-02T15:04:05Z07:00"

// Serialize to JSON
func (s Secret) MarshalJSON() ([]byte, error) <span class="cov6" title="2">{
        var (
                payload []byte
                err     error
        )

        switch SecretType(s.SecretType) </span>{
        case CredSecret:<span class="cov6" title="2">
                payload, err = json.Marshal(s.Creds)</span>
        case CardSecret:<span class="cov0" title="0">
                payload, err = json.Marshal(s.Card)</span>
        case TextSecret:<span class="cov0" title="0">
                payload, err = json.Marshal(s.Text)</span>
        case BlobSecret:<span class="cov0" title="0">
                payload, err = json.Marshal(s.Blob)</span>
        }

        <span class="cov6" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("secret payload marshaling failed: %w", err)
        }</span>

        <span class="cov6" title="2">jv, err := json.Marshal(map[string]string{
                "id":          strconv.FormatUint(s.ID, 10),
                "title":       s.Title,
                "secret_type": s.SecretType,
                "metadata":    s.Metadata,
                "payload":     string(payload),
                "created_at":  s.CreatedAt.Format(timeFormat),
                "updated_at":  s.UpdatedAt.Format(timeFormat),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("secret marshaling failed: %w", err)
        }</span>

        <span class="cov6" title="2">return jv, nil</span>
}

// Deserialize from JSON
func (s *Secret) UnmarshalJSON(src []byte) error <span class="cov6" title="2">{
        var (
                data map[string]string
                err  error
        )

        if err = json.Unmarshal(src, &amp;data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("secret unmarshaling failed: %w", err)
        }</span>

        <span class="cov6" title="2">s.ID, _ = strconv.ParseUint(data["id"], 10, 64)
        s.Title = data["title"]
        s.SecretType = data["secret_type"]
        s.Metadata = data["metadata"]
        s.CreatedAt, _ = time.Parse(timeFormat, data["created_at"])
        s.UpdatedAt, _ = time.Parse(timeFormat, data["updated_at"])

        switch SecretType(data["secret_type"]) </span>{
        case CredSecret:<span class="cov6" title="2">
                s.Creds = &amp;Credentials{}
                err = json.Unmarshal([]byte(data["payload"]), s.Creds)</span>
        case CardSecret:<span class="cov0" title="0">
                s.Card = &amp;Card{}
                err = json.Unmarshal([]byte(data["payload"]), s.Card)</span>
        case TextSecret:<span class="cov0" title="0">
                s.Text = &amp;Text{}
                err = json.Unmarshal([]byte(data["payload"]), s.Text)</span>
        case BlobSecret:<span class="cov0" title="0">
                s.Blob = &amp;Blob{}
                err = json.Unmarshal([]byte(data["payload"]), s.Blob)</span>
        }

        <span class="cov6" title="2">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("secret payload unmarshaling failed: %w", err)
        }</span>

        <span class="cov6" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Package staticlint implements multichecker static analyser with different linters.
// This package uses golang.org/x/tools/go/analysis/multichecker to combine different linters
//
// Staticlint includes:
//
// From golang.org/x/tools/go/analysis/passes:
// asmdecl, assign, atomic, atomicalign, bools, composite, copylock, deepequalerrors,
// directive, errorsas, httpresponse, ifaceassert, loopclosure, lostcancel,
// nilfunc, nilness, reflectvaluecompare, shadow, shift, sigchanyzer, sortslice,
// stdmethods, stringintconv, structtag, tests, timeformat, unmarshal,
// unreachable, unsafeptr, unusedresult, unusedwrite.
//
// See docs: https://pkg.go.dev/golang.org/x/tools/go/analysis/passes
//
// From staticheck.io:
//   - All SA* (staticcheck) linters.
//   - All S* (simple) linters.
//   - All ST* (stylecheck) linters.
//   - All QF* (quickfix) linters.
//
// See docs: https://staticcheck.io/docs/checks/
//
// Other publicly available linters:
//   - errcheck to check for unchecked errors in Go code, see
//     https://github.com/kisielk/errcheck
//   - bodyclose to check whether HTTP response body is closed and
//     a re-use of TCP connection is not blocked, see:
//     https://github.com/timakin/bodyclose
//   - rowserr to ensure whether pgx.Rows.err value is checked, see
//     https://github.com/jingyugao/rowserrcheck
//
// Custom linters:
//   - noexit to check whether os.Exit is not used in the main function of the main package.
package staticlint

import (
        "github.com/jingyugao/rowserrcheck/passes/rowserr"
        "github.com/kisielk/errcheck/errcheck"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/atomicalign"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/directive"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/nilness"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/reflectvaluecompare"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/sortslice"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/stringintconv"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/tests"
        "golang.org/x/tools/go/analysis/passes/timeformat"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"
        "golang.org/x/tools/go/analysis/passes/unusedwrite"
        "honnef.co/go/tools/analysis/lint"
        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"
)

// StaticLint is a structure to collect linters passed to multichecker
type StaticLint struct {
        checkers []*analysis.Analyzer
}

// Excluded checks taken from Yandex-practicum static lint.
var excludedChecks = map[string]struct{}{
        // Incorrect or missing package comment
        "ST1000": {},
        // The documentation of an exported function should start with the function's name
        "ST1020": {},
        // The documentation of an exported type should start with type's name
        "ST1021": {},
        // The documentation of an exported variable or constant should start with variable's name
        "ST1022": {},
}

// Constructor.
func New() StaticLint <span class="cov0" title="0">{
        // Add analyzers from passes.
        checkers := []*analysis.Analyzer{
                asmdecl.Analyzer,
                assign.Analyzer,
                atomic.Analyzer,
                atomicalign.Analyzer,
                bools.Analyzer,
                buildtag.Analyzer,
                composite.Analyzer,
                copylock.Analyzer,
                deepequalerrors.Analyzer,
                directive.Analyzer,
                errorsas.Analyzer,
                httpresponse.Analyzer,
                ifaceassert.Analyzer,
                loopclosure.Analyzer,
                lostcancel.Analyzer,
                nilfunc.Analyzer,
                nilness.Analyzer,
                printf.Analyzer,
                reflectvaluecompare.Analyzer,
                shadow.Analyzer,
                shift.Analyzer,
                sigchanyzer.Analyzer,
                sortslice.Analyzer,
                stdmethods.Analyzer,
                stringintconv.Analyzer,
                structtag.Analyzer,
                tests.Analyzer,
                timeformat.Analyzer,
                unmarshal.Analyzer,
                unreachable.Analyzer,
                unsafeptr.Analyzer,
                unusedresult.Analyzer,
                unusedwrite.Analyzer,
        }

        // Add staticcheck analyzers.
        for _, collection := range [][]*lint.Analyzer{
                staticcheck.Analyzers,
                simple.Analyzers,
                stylecheck.Analyzers,
                quickfix.Analyzers,
        } </span><span class="cov0" title="0">{
                for _, v := range collection </span><span class="cov0" title="0">{
                        if _, exclude := excludedChecks[v.Analyzer.Name]; exclude </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">checkers = append(checkers, v.Analyzer)</span>
                }
        }

        // Add standalone analyzers.
        <span class="cov0" title="0">checkers = append(checkers, errcheck.Analyzer)
        checkers = append(checkers, bodyclose.Analyzer)
        checkers = append(checkers, rowserr.NewAnalyzer("github.com/jackc/pgx/v5"))

        return StaticLint{checkers}</span>
}

// Run linting.
func (s StaticLint) Run() <span class="cov0" title="0">{
        multichecker.Main(s.checkers...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
